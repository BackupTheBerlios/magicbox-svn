diff -Nru pcmcia-cs-3.2.8.orig/Makefile pcmcia-cs-3.2.8-hermesap-and-fixes/Makefile
--- pcmcia-cs-3.2.8.orig/Makefile	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/Makefile	2006-03-18 16:27:06.000000000 +0100
@@ -6,10 +6,10 @@
 include config.mk
 endif
 
-ALL  = modules clients wireless cardmgr flash debug-tools man etc
-DIRS = cardmgr flash debug-tools man etc
+ALL  = modules wireless cardmgr man etc
+DIRS = cardmgr man etc
 ifndef CONFIG_PCMCIA
-DIRS := modules clients wireless $(DIRS)
+DIRS := modules wireless $(DIRS)
 endif
 
 help:
diff -Nru pcmcia-cs-3.2.8.orig/cardmgr/Makefile pcmcia-cs-3.2.8-hermesap-and-fixes/cardmgr/Makefile
--- pcmcia-cs-3.2.8.orig/cardmgr/Makefile	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/cardmgr/Makefile	2006-03-18 16:27:06.000000000 +0100
@@ -46,12 +46,12 @@
 I_EXTRA	+= install-gpccard
 endif
 
-ifdef CONFIG_ISA
-PROBE = pcic_probe
-ifdef PREFIX
-I_EXTRA += install-probe
-endif
-endif
+#ifdef CONFIG_ISA
+#PROBE = pcic_probe
+#ifdef PREFIX
+#I_EXTRA += install-probe
+#endif
+#endif
 
 all:	$(SRCS) $(TOOLS) $(EXTRA) $(PROBE)
 
diff -Nru pcmcia-cs-3.2.8.orig/clients/Makefile pcmcia-cs-3.2.8-hermesap-and-fixes/clients/Makefile
--- pcmcia-cs-3.2.8.orig/clients/Makefile	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/clients/Makefile	2006-03-18 16:27:06.000000000 +0100
@@ -15,8 +15,8 @@
 
 SRCS    = serial_cs.c memory_cs.c ftl_cs.c dummy_cs.c \
 	  sram_mtd.c iflash2_mtd.c iflash2+_mtd.c
-MODULES = serial_cs.o memory_cs.o ftl_cs.o dummy_cs.o \
-	  sram_mtd.o iflash2_mtd.o iflash2+_mtd.o
+MODULES = 
+
 EXTRA   =
 I_EXTRA =
 
diff -Nru pcmcia-cs-3.2.8.orig/include/pcmcia/config.h pcmcia-cs-3.2.8-hermesap-and-fixes/include/pcmcia/config.h
--- pcmcia-cs-3.2.8.orig/include/pcmcia/config.h	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/include/pcmcia/config.h	2006-03-18 16:29:46.000000000 +0100
@@ -1,6 +1,7 @@
 #ifndef _PCMCIA_CONFIG_H
 #define _PCMCIA_CONFIG_H
 
+#include_next <linux/config.h>
 #define AUTOCONF_INCLUDED
 #define __IN_PCMCIA_PACKAGE__
 
diff -Nru pcmcia-cs-3.2.8.orig/modules/Makefile pcmcia-cs-3.2.8-hermesap-and-fixes/modules/Makefile
--- pcmcia-cs-3.2.8.orig/modules/Makefile	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/modules/Makefile	2006-03-18 16:27:20.000000000 +0100
@@ -7,7 +7,7 @@
 # Include site dependent options and kernel configuration
 include ../config.mk
 
-CPPFLAGS += $(PCDEBUG) -D__KERNEL__ -DMODULE
+CPPFLAGS += $(PCDEBUG) -D__KERNEL__ -DMODULE -I$(LINUX)/arch/ppc
 CC = $(KCC) $(AFLAGS) $(KFLAGS)
 
 SRCS    = cs.c cistpl.c rsrc_mgr.c bulkmem.c ds.c
diff -Nru pcmcia-cs-3.2.8.orig/wireless/Makefile pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/Makefile
--- pcmcia-cs-3.2.8.orig/wireless/Makefile	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/Makefile	2006-03-18 16:27:20.000000000 +0100
@@ -7,23 +7,17 @@
 # Include site dependent options and kernel configuration
 include ../config.mk
 
-CPPFLAGS += $(PCDEBUG) -D__KERNEL__ -DMODULE
+CPPFLAGS += $(PCDEBUG) -D__KERNEL__ -DMODULE -I$(LINUX)/arch/ppc
 CC = $(KCC) $(AFLAGS) $(KFLAGS)
 
-MODULES = netwave_cs.o wavelan_cs.o ray_cs.o wvlan_cs.o airo_cs.o airo.o
-SRCS    = netwave_cs.c wavelan_cs.c ray_cs.c airo_cs.c airo.c \
-	  wvlan_cs.c wvlan_hcf.c wvlan_hcfio.c
+MODULES = 
+SRCS    = 
 
-ifdef DO_ORINOCO
 MODULES += hermes.o orinoco.o orinoco_cs.o orinoco_plx.o
 SRCS    += hermes.c orinoco.c orinoco_cs.c orinoco_plx.c
-endif
 
 all:	$(MODULES)
 
-wvlan_cs.o: wvlan_base.o wvlan_hcf.o wvlan_hcfio.o
-	$(LD) -r -o $@ $+ ; chmod -x $@
-
 clean:
 	rm -f core core.* *.o .*.o *.s *.a *~ .depend .depfiles/*.d
 
diff -Nru pcmcia-cs-3.2.8.orig/wireless/README.orinoco pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/README.orinoco
--- pcmcia-cs-3.2.8.orig/wireless/README.orinoco	1970-01-01 01:00:00.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/README.orinoco	2006-03-18 16:27:20.000000000 +0100
@@ -0,0 +1,196 @@
+orinoco_cs: Orinoco and Prism 2 wireless card driver
+----------------------------------------------------
+
+A new driver for Lucent/Cabletron IEEE 802.11 wireless cards as well
+as most Prism II based wireless cards. This driver is designed as a
+replacement for the wvlan_cs.c driver - it's supposed to clean up some
+things in that driver, in particular its dependence on the rather ugly
+HCF-Light library from Lucent.
+
+This driver has been included in the Linux kernel since version 2.4.3.
+Usually it's easisest to use the driver in the kernel, only use the
+versions here if you need the latest experimental versions or if you
+need a later version but for some reason can't upgrade your kernel.
+
+Contact:	David Gibson <hermes@gibson.dropbear.id.au>
+
+Frequently Asked Questions:
+
+Q: I have a question that's not answered here.  Where do I ask it?
+
+A: For general questions and bug reports about the orinoco driver, use
+   the <orinoco-users@lists.sourceforge.net> list.  You can subscribe
+   at:
+	https://lists.sourceforge.net/lists/listinfo/orinoco-users
+
+   For technical questions, feature request and development
+   discussion, use the <orinoco-devel@lists.sourceforge.net> list.
+   You can subscribe at:
+	https://lists.sourceforge.net/lists/listinfo/orinoco-devel
+
+   For discussion of wireless networking issues which aren't orinoco
+   driver specific (e.g. plans for community networks, which cards to
+   purchase, where to get or how to design external antennae) try the
+   <wireless@lists.samba.org list>.  You can subscribe at:
+	http://lists.samba.org/listinfo/wireless
+   *NB*:  This list was originally intended for discussion of
+   community wireless networks in Australia.  It seems to have drifted
+   to cover a wider area, but YMMV.  I take no responsibility if you
+   are flamed for being off-topic :-)
+
+
+Q: How do I compile/install the driver?
+
+A: The easiest way is to use the version included in the kernel
+   source, or in David Hinds' pcmcia-cs package.
+
+   If you need to install a newer version from ozlabs.org, you will
+   need the kernel source for the kernel you are currently running.
+   The Makefile included with the driver assumes that the link 
+   /lib/modules/<version>/build points to this, and that you are using
+   the pcmcia modules from the kernel, rather than from pcmcia-cs.  If
+   that's true, then just unpack the driver tar file, run "make",
+   become root and run "make install".
+
+
+Q: My machines with the orinoco driver in ad-hoc mode can't talk to
+   machines running the wvlan_cs driver / FreeBSD's if_wi driver.
+   What's up?
+
+A: There are actually two versions of ad-hoc mode which are not
+   interoperable.  One is the IEEE standard "IBSS" mode and the other
+   is a Lucent proprietary protocol known as "demo ad-hoc mode".  The
+   orinoco driver defaults to using IBSS mode on firmware which
+   supports it (>= 6.06 for Lucent cards), the wvlan_cs and FreeBSD
+   driver default to demo ad-hoc mode.  You'll have to switch one or
+   the other end so they're using the same mode:
+
+   For orinoco_cs/orinoco_plx/airport the command:
+		iwpriv ethXX set_port3 1
+	will select demo ad-hoc mode, and:
+		iwpriv ethXX set_port3 0
+	will select IBSS mode.
+   For wvlan_cs the module parameters:
+		 port_type=1 allow_ibss=1
+	will select IBSS mode and
+		port_type=3
+	will select demo ad-hoc mode.
+   For FreeBSD the command
+		wicontrol -p 1 && wicontrol -C 1
+	will select IBSS mode, and
+		wicontrol -p 3
+	will select demo ad-hoc mode.
+
+
+Q: Why do I get lots of "Error -16 writing packet header to BAP"
+   messages in my log?
+
+A: This is an error reported by the firmware, but it is triggered
+   by a major bug in all versions of the driver prior to 0.09a.
+   Upgrade to the latest driver as soon as possible.
+
+
+Q: I get lots of "Error -110 writing Tx descriptor to BAP" or "Error
+   -110 writing packet header to BAP" messages, whenever I try to do a
+   big transfer.   What's going on?
+
+A: This is a persistent problem that we've had dealing with Intersil
+   firmware, that we're having a lot of trouble pinning down and
+   squashing.
+
+   The error means that we're timing out while waiting for the
+   firmware to respond to a request to write data into the card, ready
+   for transmission.  It's not entirely clear why the firmware
+   sometimes responds so slowly, in fact there now seems to be some
+   evidence that there are multiple causes for this problem.
+
+   At least one of the causes for this problem has been squashed in
+   0.13 and later versions (the card's two supposedly independent BAPs
+   aren't quite).  However there may be other more obscure cases in
+   which it occurs.
+
+   I'm very interested in reports of this behaviour on current
+   versions, to try and find some patterns to the behaviour.  In
+   particular I'm interested to hear whether the problem occurs (in 0.13
+   or later) with WEP disabled.
+
+   There is a report that setting a low RTS threshold (say 250
+   bytes) works around this problem (though it's certainly not an
+   optimal solution).
+
+
+Q: Are the mini-PCI wireless cards used in Dell laptops (and some
+   other brands) supported?
+
+A: Some of these are essentially a PCMCIA card with a PCI to
+   PCMCIA bridge packaged into the mini-PCI form factor, so the PCMCIA
+   subsystem should see it as a PCMCIA slot and be able to initialise
+   the card.
+
+   Some newer laptops have genuine PCI cards based on the Prism 2.5
+   chipset.  These are supported by the orinoco_pci driver (note that
+   this driver is not as well tested as the PCMCIA version).
+
+   Some even newer Dell laptops have a PCI 802.11b card based on a
+   Broadcom chip.  As far as I can tell this is a different beast from
+   the Prism chipset entirely, and definitely not supported by this
+   driver.
+
+
+Q: How do I get the driver to work on my ARM based machine?
+
+A: There seems to be a problem which causes one of the structures used
+   in the driver to be misaligned on ARM machines (I believe this is a
+   compiler bug on ARM).  For now try compiling the driver with the
+   option "-mstructure-size-boundary=8" - eventually the use of the
+   structure in this manner is likely to be phased out removing the
+   problem.  This should no longer be necessary as of version 0.10.
+
+
+Q: I compiled the module from the sources on www.ozlabs.org, but when
+   I try to load it, I get lots of "unresolved symbol" messages.
+
+A: Red Hat, Debian and most other distributions compile their kernels
+   with "module symbol versioning" (CONFIG_MODVERSIONS) enabled.  This
+   causes some problems with compiling modules outside the kernel tree
+   itself.  You can either recompile the kernel with this option
+   disabled, then recompile the module, or try adding:
+	-DMODVERSIONS -include $(KERNEL_SRC)/include/linux/modversions.h
+   to the CPPFLAGS option in the orinoco module Makefile.
+
+
+Q: The driver doesn't work and I get a message like "get dev info on
+   socket 1 failed: Resource temporarily unavailable".
+
+A: This isn't a problem in the orinoco driver - this error is from the
+   PCMCIA subsystem before the driver is even activated.  It usually
+   indicates a PCMCIA configuration problem.
+
+  In particular it can be cause if you attempt to use the orinoco
+  driver by putting:
+	device "wvlan_cs"
+	  class "network" module "orinoco_cs"
+  or similar in /etc/pcmcia/config.  Instead you must individually
+  bind each card to the "orinoco_cs" device.
+
+  Usually, all you should need to do is leave the PCMCIA standard
+  config files alone, and just drop hermes.conf from the driver
+  package into /etc/pcmcia.
+
+
+Q: When I try to compile the driver I get errors about "implicit
+   declaration of min/max/min_t/max_t".
+
+A: The driver uses the new type safe min and max macros introduced in
+   2.4.10.  You're using a copy of the kernel source from before
+   this.  Get some newer kernel source, or use the version of the
+   driver included in David Hinds' pcmcia-cs package (which includes
+   compatibility code).
+
+
+Q: I using version 0.12(something) and I'm getting lockups / it's not
+   working.
+
+A: Don't use any of the 0.12 versions.  A blunder on my part meant
+   that we are attempting to use a locking model that's incompatible
+   with the network layer.
diff -Nru pcmcia-cs-3.2.8.orig/wireless/airport.c pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/airport.c
--- pcmcia-cs-3.2.8.orig/wireless/airport.c	1970-01-01 01:00:00.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/airport.c	2006-03-18 16:27:20.000000000 +0100
@@ -0,0 +1,278 @@
+/* airport.c 0.13c
+ *
+ * A driver for "Hermes" chipset based Apple Airport wireless
+ * card.
+ *
+ * Copyright notice & release notes in file orinoco.c
+ * 
+ * Note specific to airport stub:
+ * 
+ *  0.05 : first version of the new split driver
+ *  0.06 : fix possible hang on powerup, add sleep support
+ */
+
+#include <linux/config.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/adb.h>
+#include <linux/pmu.h>
+
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/pmac_feature.h>
+#include <asm/irq.h>
+
+#include "orinoco.h"
+
+#define AIRPORT_IO_LEN	(0x1000)	/* one page */
+
+struct airport {
+	struct device_node *node;
+	void *vaddr;
+	int irq_requested;
+	int ndev_registered;
+};
+
+#ifdef CONFIG_PMAC_PBOOK
+static int airport_sleep_notify(struct pmu_sleep_notifier *self, int when);
+static struct pmu_sleep_notifier airport_sleep_notifier = {
+	airport_sleep_notify, SLEEP_LEVEL_NET,
+};
+#endif
+
+/*
+ * Function prototypes
+ */
+
+static struct net_device *airport_attach(struct device_node *of_node);
+static void airport_detach(struct net_device *dev);
+
+static struct net_device *airport_dev;
+
+#ifdef CONFIG_PMAC_PBOOK
+static int
+airport_sleep_notify(struct pmu_sleep_notifier *self, int when)
+{
+	struct net_device *dev = airport_dev;
+	struct orinoco_private *priv = dev->priv;
+	struct airport *card = priv->card;
+	unsigned long flags;
+	int err;
+	
+	if (! airport_dev)
+		return PBOOK_SLEEP_OK;
+
+	switch (when) {
+	case PBOOK_SLEEP_NOW:
+		printk(KERN_DEBUG "%s: Airport entering sleep mode\n", dev->name);
+
+		orinoco_action(priv, ORINOCO_DETACH);
+
+		disable_irq(dev->irq);
+		pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 0);
+		break;
+
+	case PBOOK_WAKE:
+		printk(KERN_DEBUG "%s: Airport waking up\n", dev->name);
+		pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 1);
+		mdelay(200);
+
+		enable_irq(dev->irq);
+
+		err = orinoco_reinit_firmware(dev);
+		if (err) {
+			printk(KERN_ERR "%s: Error %d re-initializing firmware on PBOOK_WAKE\n",
+			       dev->name, err);
+			break;
+		}
+
+		orinoco_action(priv, ORINOCO_ATTACH);
+
+		break;
+	}
+	return PBOOK_SLEEP_OK;
+}
+#endif /* CONFIG_PMAC_PBOOK */
+
+static int airport_hard_reset(struct orinoco_private *priv)
+{
+	struct airport *card = priv->card;
+
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 0);
+	current->state = TASK_UNINTERRUPTIBLE;
+	schedule_timeout(HZ);
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 1);
+	current->state = TASK_UNINTERRUPTIBLE;
+	schedule_timeout(HZ);
+
+	return 0;
+}
+
+static struct net_device *
+airport_attach(struct device_node *of_node)
+{
+	struct orinoco_private *priv;
+	struct net_device *dev;
+	struct airport *card;
+	unsigned long phys_addr;
+	hermes_t *hw;
+
+	if (of_node->n_addrs < 1 || of_node->n_intrs < 1) {
+		printk(KERN_ERR "airport: wrong interrupt/addresses in OF tree\n");
+		return NULL;
+	}
+
+	/* Allocate space for private device-specific data */
+	dev = alloc_orinocodev(sizeof(*card), airport_hard_reset);
+	if (! dev) {
+		printk(KERN_ERR "airport: can't allocate device datas\n");
+		return NULL;
+	}
+	priv = dev->priv;
+	card = priv->card;
+
+	hw = &priv->hw;
+	card->node = of_node;
+
+	if (! request_OF_resource(of_node, 0, " (airport)")) {
+		printk(KERN_ERR "airport: can't request IO resource !\n");
+		kfree(dev);
+		return NULL;
+	}
+
+	dev->name[0] = '\0';	/* register_netdev will give us an ethX name */
+	SET_MODULE_OWNER(dev);
+
+	/* Setup interrupts & base address */
+	dev->irq = of_node->intrs[0].line;
+	phys_addr = of_node->addrs[0].address;  /* Physical address */
+	printk(KERN_DEBUG "Airport at physical address %lx\n", phys_addr);
+	dev->base_addr = phys_addr;
+	card->vaddr = ioremap(phys_addr, AIRPORT_IO_LEN);
+	if (! card->vaddr) {
+		printk("airport: ioremap() failed\n");
+		goto failed;
+	}
+
+	hermes_struct_init(hw, (ulong)card->vaddr,
+			HERMES_MEM, HERMES_16BIT_REGSPACING);
+		
+	/* Power up card */
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 1);
+	current->state = TASK_UNINTERRUPTIBLE;
+	schedule_timeout(HZ);
+
+	/* Reset it before we get the interrupt */
+	hermes_init(hw);
+
+	if (request_irq(dev->irq, orinoco_interrupt, 0, "Airport", dev)) {
+		printk(KERN_ERR "airport: Couldn't get IRQ %d\n", dev->irq);
+		goto failed;
+	}
+	card->irq_requested = 1;
+
+	/* Tell the stack we exist */
+	if (orinoco_action(priv, ORINOCO_REGISTER) )
+		goto failed;
+
+	printk(KERN_DEBUG "airport: card registered for interface %s\n", dev->name);
+	card->ndev_registered = 1;
+
+	/* register the memory access device */
+	orinoco_mem_dev_init(priv);
+	
+#ifdef CONFIG_PMAC_PBOOK
+	pmu_register_sleep_notifier(&airport_sleep_notifier);
+#endif
+	return dev;
+	
+ failed:
+	airport_detach(dev);
+	return NULL;
+}				/* airport_attach */
+
+/*======================================================================
+  This deletes a driver "instance".  
+  ======================================================================*/
+
+static void
+airport_detach(struct net_device *dev)
+{
+	struct orinoco_private *priv = dev->priv;
+	struct airport *card = priv->card;
+
+#ifdef CONFIG_PMAC_PBOOK
+	pmu_unregister_sleep_notifier(&airport_sleep_notifier);
+#endif
+
+	/* unregister memory access device */
+	orinoco_mem_dev_cleanup(priv);
+	
+	if (card->ndev_registered)
+		orinoco_action(priv, ORINOCO_UNREGISTER);
+	card->ndev_registered = 0;
+
+	if (card->irq_requested)
+		free_irq(dev->irq, priv);
+	card->irq_requested = 0;
+
+	if (card->vaddr)
+		iounmap(card->vaddr);
+	card->vaddr = 0;
+
+	dev->base_addr = 0;
+
+	release_OF_resource(card->node, 0);
+
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 0);
+	current->state = TASK_UNINTERRUPTIBLE;
+	schedule_timeout(HZ);
+
+	kfree(dev);
+}				/* airport_detach */
+
+static char version[] __initdata = "airport.c 0.13c (Benjamin Herrenschmidt <benh@kernel.crashing.org>)";
+MODULE_AUTHOR("Benjamin Herrenschmidt <benh@kernel.crashing.org>");
+MODULE_DESCRIPTION("Driver for the Apple Airport wireless card.");
+MODULE_LICENSE("Dual MPL/GPL");
+
+static int __init
+init_airport(void)
+{
+	struct device_node *airport_node;
+
+	printk(KERN_DEBUG "%s\n", version);
+
+	/* Lookup card in device tree */
+	airport_node = find_devices("radio");
+	if (airport_node && !strcmp(airport_node->parent->name, "mac-io"))
+		airport_dev = airport_attach(airport_node);
+
+	return airport_dev ? 0 : -ENODEV;
+}
+
+static void __exit
+exit_airport(void)
+{
+	if (airport_dev)
+		airport_detach(airport_dev);
+	airport_dev = NULL;
+}
+
+module_init(init_airport);
+module_exit(exit_airport);
diff -Nru pcmcia-cs-3.2.8.orig/wireless/hermes.c pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/hermes.c
--- pcmcia-cs-3.2.8.orig/wireless/hermes.c	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/hermes.c	2006-03-18 16:27:20.000000000 +0100
@@ -15,6 +15,9 @@
  *
  * Copyright (C) 2000, David Gibson, Linuxcare Australia <hermes@gibson.dropbear.id.au>
  * Copyright (C) 2001, David Gibson, IBM <hermes@gibson.dropbear.id.au>
+ *
+ * AUX Port stuff Copyright (C) 2003, Benedikt 'Hunz' Heinz <hunz@hunz.org>
+ * (code of David Gibson and Jouni Malinen <jkmaline@cc.hut.fi> also used)
  * 
  * The contents of this file are subject to the Mozilla Public License
  * Version 1.1 (the "License"); you may not use this file except in
@@ -52,6 +55,7 @@
 
 #include "hermes.h"
 
+static char version[] __initdata = "hermes.c: 4 Dec 2002 David Gibson <hermes@gibson.dropbear.id.au>";
 MODULE_DESCRIPTION("Low-level driver helper for Lucent Hermes chipset and Prism II HFA384x wireless MAC controller");
 MODULE_AUTHOR("David Gibson <hermes@gibson.dropbear.id.au>");
 #ifdef MODULE_LICENSE
@@ -225,8 +229,7 @@
  * Returns: < 0 on internal error, 0 on success, > 0 on error returned by the firmware
  *
  * Callable from any context, but locking is your problem. */
-int hermes_docmd_wait(hermes_t *hw, u16 cmd, u16 parm0,
-		      hermes_response_t *resp)
+int hermes_docmd_wait(hermes_t *hw, u16 cmd, u16 parm0, hermes_response_t *resp)
 {
 	int err;
 	int k;
@@ -469,17 +472,13 @@
 
 	err = hermes_docmd_wait(hw, HERMES_CMD_ACCESS, rid, NULL);
 	if (err)
-		return err;
+		goto out;
 
 	err = hermes_bap_seek(hw, bap, rid, 0);
 	if (err)
-		return err;
+		goto out;
 
 	rlength = hermes_read_reg(hw, dreg);
-
-	if (! rlength)
-		return -ENOENT;
-
 	rtype = hermes_read_reg(hw, dreg);
 
 	if (length)
@@ -489,17 +488,19 @@
 		printk(KERN_WARNING "hermes @ %s0x%lx: "
 		       "hermes_read_ltv(): rid  (0x%04x) does not match type (0x%04x)\n",
 		       IO_TYPE(hw), hw->iobase, rid, rtype);
+/*
 	if (HERMES_RECLEN_TO_BYTES(rlength) > bufsize)
 		printk(KERN_WARNING "hermes @ %s0x%lx: "
 		       "Truncating LTV record from %d to %d bytes. "
 		       "(rid=0x%04x, len=0x%04x)\n",
 		       IO_TYPE(hw), hw->iobase,
 		       HERMES_RECLEN_TO_BYTES(rlength), bufsize, rid, rlength);
-
+*/
 	nwords = min((unsigned)rlength - 1, bufsize / 2);
 	hermes_read_words(hw, dreg, buf, nwords);
 
-	return 0;
+ out:
+	return err;
 }
 
 int hermes_write_ltv(hermes_t *hw, int bap, u16 rid, 
@@ -514,7 +515,7 @@
 
 	err = hermes_bap_seek(hw, bap, rid, 0);
 	if (err)
-		return err;
+		goto out;
 
 	hermes_write_reg(hw, dreg, length);
 	hermes_write_reg(hw, dreg, rid);
@@ -526,9 +527,166 @@
 	err = hermes_docmd_wait(hw, HERMES_CMD_ACCESS | HERMES_CMD_WRITE, 
 				rid, NULL);
 
+ out:
 	return err;
 }
 
+int hermes_boot_request(hermes_t *hw, u32 offset) {
+	int k = CMD_BUSY_TIMEOUT;
+	u16 reg;
+	
+	if((offset&1) || (offset>=0x800000))
+		return -EINVAL;
+
+	/* First wait for the command register to unbusy */
+	reg = hermes_read_regn(hw, CMD);
+	while ( (reg & HERMES_CMD_BUSY) && k ) {
+		k--;
+		udelay(1);
+		reg = hermes_read_regn(hw, CMD);
+	}
+	if (! hermes_present(hw)) {
+		printk(KERN_WARNING "hermes @ %s0x%lx: "
+		       "Card removed while waiting for command completion.\n",
+		       IO_TYPE(hw), hw->iobase);
+		return -ENODEV;
+	}
+	if (reg & HERMES_CMD_BUSY)
+		return -EBUSY;
+
+	hermes_write_regn(hw, PARAM2, 0);
+	hermes_write_regn(hw, PARAM1, __cpu_to_le16(offset>>17));
+	hermes_write_regn(hw, PARAM0, __cpu_to_le16((offset>>1)&0xFFFF));
+	hermes_write_regn(hw, CMD, HERMES_CMD_DOWNLD | (HERMES_PROGMODE_ENABLE_VOLATILE<<8) );
+	
+	reg = hermes_read_regn(hw, EVSTAT);
+	k = CMD_COMPL_TIMEOUT;
+	while ( (! (reg & HERMES_EV_CMD)) && k) {
+		k--;
+		udelay(10);
+		reg = hermes_read_regn(hw, EVSTAT);
+	}
+
+	if (! (reg & HERMES_EV_CMD)) {
+		printk(KERN_ERR "hermes @ %s0x%lx: "
+		       "Timeout waiting for command completion.\n",
+		       IO_TYPE(hw), hw->iobase);
+		return -ETIMEDOUT;
+	}
+
+	reg = hermes_read_regn(hw, STATUS);
+	
+	hermes_write_regn(hw, EVACK, HERMES_EV_CMD);
+
+	if ((reg & HERMES_STATUS_RESULT) || ((reg&HERMES_STATUS_CMDCODE) != HERMES_CMD_DOWNLD))
+		return -EIO;
+
+	return 0;
+}
+
+int hermes_boot_ack(hermes_t *hw) {
+	int k = CMD_BUSY_TIMEOUT;
+	u16 reg;
+
+	/* First wait for the command register to unbusy */
+	reg = hermes_read_regn(hw, CMD);
+	while ( (reg & HERMES_CMD_BUSY) && k ) {
+		k--;
+		udelay(1);
+		reg = hermes_read_regn(hw, CMD);
+	}
+
+	if (reg & HERMES_CMD_BUSY)
+		return -EBUSY;
+	
+	hermes_write_regn(hw, PARAM0, 0);
+	hermes_write_regn(hw, CMD, HERMES_CMD_DOWNLD | (HERMES_PROGMODE_DISABLE<<8) );
+	
+	reg = hermes_read_regn(hw, EVSTAT);
+	k = CMD_COMPL_TIMEOUT;
+	while ( (! (reg & HERMES_EV_CMD)) && k) {
+		k--;
+		udelay(10);
+		reg = hermes_read_regn(hw, EVSTAT);
+	}
+
+	if (! (reg & HERMES_EV_CMD)) {
+		printk(KERN_ERR "hermes @ %s0x%lx: "
+		       "Timeout waiting for command completion.\n",
+		       IO_TYPE(hw), hw->iobase);
+		return -ETIMEDOUT;
+	}
+	
+	reg = hermes_read_regn(hw, STATUS);
+	
+	hermes_write_regn(hw, EVACK, HERMES_EV_CMD);
+
+	if ((reg & HERMES_STATUS_RESULT) || ((reg&HERMES_STATUS_CMDCODE) != HERMES_CMD_DOWNLD))
+		return -EIO;
+	
+	return 0;
+}
+
+/* enable / disable AUX port */
+int hermes_aux_cntl(hermes_t *hw, int enable) {
+	int k = CMD_BUSY_TIMEOUT;
+	u16 reg;
+
+	/* First wait for the command register to unbusy */
+	reg = hermes_read_regn(hw, CMD);
+	while ( (reg & HERMES_CMD_BUSY) && k ) {
+		k--;
+		udelay(1);
+		reg = hermes_read_regn(hw, CMD);
+	}
+	if (! hermes_present(hw)) {
+		printk(KERN_WARNING "hermes @ %s0x%lx: "
+		       "Card removed while waiting for command completion.\n",
+		       IO_TYPE(hw), hw->iobase);
+		return -ENODEV;
+	}
+	if (reg & HERMES_CMD_BUSY) {
+		return -EBUSY;
+	}
+	reg=hermes_read_regn(hw, CONTROL);
+	if((reg & HERMES_AUX_PORT_MASK) == HERMES_AUX_PORT_ENABLED) {
+		if(enable)
+			return 0;
+		else {
+			reg &= ~HERMES_AUX_PORT_MASK;
+			reg|=HERMES_AUX_PORT_DISABLE;
+		}
+	}
+	else {
+		if(enable) {
+			reg &= ~HERMES_AUX_PORT_MASK;
+			reg|=HERMES_AUX_PORT_ENABLE;
+		}
+		else
+			return 0;
+	}
+	hermes_write_regn(hw, PARAM0, HERMES_AUX_MAGIC0);
+	hermes_write_regn(hw, PARAM1, HERMES_AUX_MAGIC1);
+	hermes_write_regn(hw, PARAM2, HERMES_AUX_MAGIC2);
+	hermes_write_regn(hw, CONTROL, reg);
+	udelay(5);
+	for(k=1000;k>0;k--) {
+		if ( ((enable) && ((hermes_read_regn(hw, CONTROL)&HERMES_AUX_PORT_MASK) == HERMES_AUX_PORT_ENABLED)) ||
+			((!enable) && ((hermes_read_regn(hw, CONTROL)&HERMES_AUX_PORT_MASK) == HERMES_AUX_PORT_DISABLED)) )
+			break;
+		udelay(10);
+	}
+	if (! hermes_present(hw)) {
+		printk(KERN_WARNING "hermes @ %s0x%lx: "
+		       "Card removed while waiting for command completion.\n",
+		       IO_TYPE(hw), hw->iobase);
+		return -ENODEV;
+	}
+	if(!k)
+		return -ETIMEDOUT;
+	return 0;
+}
+
 EXPORT_SYMBOL(hermes_struct_init);
 EXPORT_SYMBOL(hermes_init);
 EXPORT_SYMBOL(hermes_docmd_wait);
@@ -539,14 +697,16 @@
 EXPORT_SYMBOL(hermes_read_ltv);
 EXPORT_SYMBOL(hermes_write_ltv);
 
+/* AUX port stuff */
+EXPORT_SYMBOL(hermes_aux_cntl);
+EXPORT_SYMBOL(hermes_boot_request);
+EXPORT_SYMBOL(hermes_boot_ack);
+
 static int __init init_hermes(void)
 {
-	return 0;
-}
+	printk(KERN_DEBUG "%s\n", version);
 
-static void __exit exit_hermes(void)
-{
+	return 0;
 }
 
 module_init(init_hermes);
-module_exit(exit_hermes);
diff -Nru pcmcia-cs-3.2.8.orig/wireless/hermes.conf pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/hermes.conf
--- pcmcia-cs-3.2.8.orig/wireless/hermes.conf	1970-01-01 01:00:00.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/hermes.conf	2006-03-18 16:27:20.000000000 +0100
@@ -0,0 +1,106 @@
+device "orinoco_cs"
+  class "network"
+  module "hermes", "orinoco", "orinoco_cs"
+#  module "hermes", "orinoco", "orinoco_cs" opts "pc_debug=3"
+
+#
+# Wireless network adapters
+#
+# We should use the manfid (which cover multiple cards), otherwise we will
+# go crazy listing all cards and their variations !!!
+
+# First class of device : Lucent & OEM
+card "Orinoco or Intersil Prism 2 Wireless"
+  manfid 0x0156,0x0002
+  bind "orinoco_cs"
+
+card "Lucent Technologies Wavelan/IEEE"
+  version "Lucent Technologies", "WaveLAN/IEEE"
+  bind "orinoco_cs"
+
+card "Avaya World Card"
+  version "Avaya Communication", "Avaya Wireless PC Card"
+  bind "orinoco_cs"
+
+card "Cabletron RoamAbout 802.11 DS"
+  version "Cabletron", "RoamAbout 802.11 DS"
+  bind "orinoco_cs"
+
+card "ELSA AirLancer MC-11"
+  version "ELSA", "AirLancer MC-11"
+  bind "orinoco_cs"
+
+card "MELCO WLI-PCM-L11"
+  version "MELCO", "WLI-PCM-L11"
+  bind "orinoco_cs"
+
+# Second class of device : Symbol & OEM
+card "LA4111 Spectrum24 Wireless LAN PC Card"
+  version "Symbol Technologies"
+  bind "orinoco_cs"
+
+card "3Com AirConnect"
+  version "3Com", "3CRWE737A AirConnect Wireless LAN PC Card"
+  bind "orinoco_cs"
+
+card "Intel PRO/Wireless 2011"
+  manfid 0x0089,0x0001
+  bind "orinoco_cs"
+
+card "Ericsson WLAN Card C11"
+  manfid 0x016b,0x0001
+  bind "orinoco_cs" 
+
+card "Nortel Networks e-mobility 802.11 Wireless LAN PC Card"
+  version "Nortel Networks", "emobility 802.11 Wireless LAN PC Card", "1.00"
+  bind "orinoco_cs"
+
+card "D-Link DWL-650H"
+  version "D-Link Corporation", "D-Link DWL-650H 11Mbps WLAN Adapter"
+  bind "orinoco_cs"
+
+# Third class of device : other Intersil clones
+card "Farallon SkyLINE"
+  version "INTERSIL", "HFA384x/IEEE"
+  bind "orinoco_cs"
+
+card "D-Link DWL-650"
+  version "D", "Link DWL-650 11Mbps WLAN Card"
+  bind "orinoco_cs"
+
+card "SAMSUNG 11Mbps WLAN Card"
+  version "SAMSUNG", "11Mbps WLAN Card"
+  bind "orinoco_cs"
+# Does this one cover Compaq as well ???
+
+card "HyperLink Wireless PC Card 11Mbps"
+  version "HyperLink","Wireless PC Card 11Mbps"
+  bind "orinoco_cs"
+
+card "PROXIM LAN PC CARD HARMONY 80211B"
+  version "PROXIM","LAN PC CARD HARMONY 80211B"
+  bind "orinoco_cs"
+
+card "Linksys WPC11 11Mbps 802.11b WLAN Card"
+  version "Instant Wireless ", " Network PC CARD", "Version 01.02"
+  bind "orinoco_cs"
+
+card "Linksys WPC11 11Mbps 802.11b WLAN Card"
+  version "The Linksys Group, Inc.", "Instant Wireless Network PC Card", "ISL37300P", "RevA"
+  bind "orinoco_cs"
+
+card "Linksys CompactFlash Wireless Card"
+  version "Linksys", "Wireless CompactFlash Card"
+  bind "orinoco_cs"
+
+card "Tekram PCF-200"
+  version "PCMCIA", "11M WLAN Card v2.5", "ISL37300P", "RevA"
+  bind "orinoco_cs"
+
+card "ACTIONTEC PRISM Wireless LAN PC Card"
+  version "ACTIONTEC", "PRISM Wireless LAN PC Card"
+  bind "orinoco_cs"
+
+card "Zcomax XI-325HP"
+  version " ", "IEEE 802.11 Wireless LAN/PC Card"
+  bind "orinoco_cs"
diff -Nru pcmcia-cs-3.2.8.orig/wireless/hermes.h pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/hermes.h
--- pcmcia-cs-3.2.8.orig/wireless/hermes.h	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/hermes.h	2006-03-18 16:27:20.000000000 +0100
@@ -50,6 +50,16 @@
 #define		HERMES_CHINFORESULT_MAX		(8)
 #define		HERMES_MAX_MULTICAST		(16)
 #define		HERMES_MAGIC			(0x7d1f)
+#define		HERMES_AUX_MAGIC0		(0xfe01)
+#define		HERMES_AUX_MAGIC1		(0xdc23)
+#define		HERMES_AUX_MAGIC2		(0xba45)
+#define		HERMES_AUX_PORT_MASK		(0xc000)
+#define		HERMES_AUX_PORT_DISABLED	(0x0000)
+#define		HERMES_AUX_PORT_DISABLE		(0x4000)
+#define		HERMES_AUX_PORT_ENABLE		(0x8000)
+#define		HERMES_AUX_PORT_ENABLED		(0xc000)
+#define		HERMES_AUX_PAGES		(0x10000)
+#define		HERMES_AUX_PAGESIZE		(0x0080)
 
 /*
  * Hermes register offsets
@@ -148,6 +158,12 @@
 #define		HERMES_MONITOR_ENABLE		(0x000b)
 #define		HERMES_MONITOR_DISABLE		(0x000f)
 
+/*--- ProgMode Commands ------------------------------*/
+#define		HERMES_PROGMODE_DISABLE		(0x0000)
+#define		HERMES_PROGMODE_ENABLE_VOLATILE	(0x0001)
+#define		HERMES_PROGMODE_ENABLE_NON_VOLATILE	(0x0002)
+#define		HERMES_PROGMODE_PROGRAM_NON_VOLATILE	(0x0003)
+
 /*
  * Frame structures and constants
  */
@@ -202,6 +218,8 @@
 #define HERMES_INQ_TALLIES		(0xF100)
 #define HERMES_INQ_SCAN			(0xF101)
 #define HERMES_INQ_LINKSTATUS		(0xF200)
+#define HERMES_INQ_ASSOCSTATUS		(0xF201)
+#define HERMES_INQ_AUTHSTATUS		(0xF202)
 
 struct hermes_tallies_frame {
 	u16 TxUnicastFrames;
@@ -250,6 +268,7 @@
 	u16 scanreason;             /* ??? */
 	struct hermes_scan_apinfo aps[35];        /* Scan result */
 } __attribute__ ((packed));
+
 #define HERMES_LINKSTATUS_NOT_CONNECTED   (0x0000)  
 #define HERMES_LINKSTATUS_CONNECTED       (0x0001)
 #define HERMES_LINKSTATUS_DISCONNECTED    (0x0002)
@@ -277,7 +296,7 @@
 
 /* Basic control structure */
 typedef struct hermes {
-	unsigned long iobase;
+	ulong iobase;
 	int io_space; /* 1 if we IO-mapped IO, 0 for memory-mapped IO? */
 #define HERMES_IO	1
 #define HERMES_MEM	0
@@ -323,6 +342,9 @@
 		    u16 *length, void *buf);
 int hermes_write_ltv(hermes_t *hw, int bap, u16 rid,
 		      u16 length, const void *value);
+int hermes_boot_request(hermes_t *hw, u32 offset);
+int hermes_boot_ack(hermes_t *hw);
+int hermes_aux_cntl(hermes_t *hw, int enable);
 
 /* Inline functions */
 
@@ -331,6 +353,10 @@
 	return hermes_read_regn(hw, SWSUPPORT0) == HERMES_MAGIC;
 }
 
+static inline int hermes_aux_enabled(hermes_t *hw) {
+	 return (hermes_read_regn(hw, CONTROL) & HERMES_AUX_PORT_MASK) == HERMES_AUX_PORT_ENABLED;
+}
+
 static inline void hermes_set_irqmask(hermes_t *hw, u16 events)
 {
 	hw->inten = events;
@@ -367,7 +393,7 @@
 	if (hw->io_space) {
 		insw(hw->iobase + off, buf, count);
 	} else {
-		unsigned i;
+		int i;
 		u16 *p;
 
 		/* This needs to *not* byteswap (like insw()) but
@@ -387,7 +413,7 @@
 	if (hw->io_space) {
 		outsw(hw->iobase + off, buf, count);
 	} else {
-		unsigned i;
+		int i;
 		const u16 *p;
 
 		/* This needs to *not* byteswap (like outsw()) but
@@ -400,21 +426,6 @@
 	}
 }
 
-static inline void hermes_clear_words(struct hermes *hw, int off, unsigned count)
-{
-	unsigned i;
-
-	off = off << hw->reg_spacing;;
-
-	if (hw->io_space) {
-		for (i = 0; i < count; i++)
-			outw(0, hw->iobase + off);
-	} else {
-		for (i = 0; i < count; i++)
-			writew(0, hw->iobase + off);
-	}
-}
-
 #define HERMES_READ_RECORD(hw, bap, rid, buf) \
 	(hermes_read_ltv((hw),(bap),(rid), sizeof(*buf), NULL, (buf)))
 #define HERMES_WRITE_RECORD(hw, bap, rid, buf) \
diff -Nru pcmcia-cs-3.2.8.orig/wireless/hermes_rid.h pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/hermes_rid.h
--- pcmcia-cs-3.2.8.orig/wireless/hermes_rid.h	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/hermes_rid.h	2006-03-18 16:27:20.000000000 +0100
@@ -27,6 +27,7 @@
 #define HERMES_RID_CNFWDSADDRESS5		0xFC15
 #define HERMES_RID_CNFWDSADDRESS6		0xFC16
 #define HERMES_RID_CNFMULTICASTPMBUFFERING	0xFC17
+#define HERMES_RID_CNFHIDDENMODE		0xFC18
 #define HERMES_RID_CNFWEPENABLED_AGERE		0xFC20	/* used */
 #define HERMES_RID_CNFMANDATORYBSSID_SYMBOL	0xFC21
 #define HERMES_RID_CNFWEPDEFAULTKEYID		0xFC23	/* used */
@@ -75,6 +76,13 @@
 #define HERMES_RID_CNFRTSTHRESHOLD4		0xFC9B
 #define HERMES_RID_CNFRTSTHRESHOLD5		0xFC9C
 #define HERMES_RID_CNFRTSTHRESHOLD6		0xFC9D
+#define HERMES_RID_CNFTXRATECONTROL0		0xFC9E
+#define HERMES_RID_CNFTXRATECONTROL1		0xFC9F
+#define HERMES_RID_CNFTXRATECONTROL2		0xFCA0
+#define HERMES_RID_CNFTXRATECONTROL3		0xFCA1
+#define HERMES_RID_CNFTXRATECONTROL4		0xFCA2
+#define HERMES_RID_CNFTXRATECONTROL5		0xFCA3
+#define HERMES_RID_CNFTXRATECONTROL6		0xFCA4
 #define HERMES_RID_CNFSHORTPREAMBLE		0xFCB0
 #define HERMES_RID_CNFWEPKEYS_AGERE		0xFCB0	/* used */
 #define HERMES_RID_CNFEXCLUDELONGPREAMBLE	0xFCB1
diff -Nru pcmcia-cs-3.2.8.orig/wireless/ieee802_11.h pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/ieee802_11.h
--- pcmcia-cs-3.2.8.orig/wireless/ieee802_11.h	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/ieee802_11.h	2006-03-18 16:27:20.000000000 +0100
@@ -9,8 +9,6 @@
    bytes is allowed, which is a bit confusing, I suspect this
    represents the 2304 bytes of real data, plus a possible 8 bytes of
    WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
-
-
 #define IEEE802_11_HLEN			30
 #define IEEE802_11_FRAME_LEN		(IEEE802_11_DATA_LEN + IEEE802_11_HLEN)
 
diff -Nru pcmcia-cs-3.2.8.orig/wireless/monitor.h pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/monitor.h
--- pcmcia-cs-3.2.8.orig/wireless/monitor.h	1970-01-01 01:00:00.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/monitor.h	2006-03-18 16:27:20.000000000 +0100
@@ -0,0 +1,169 @@
+/* monitor.h
+ *
+ * orinoco monitoring definitions
+ * taken from http://airsnort.shmoo.com/orinocoinfo.html
+ */
+
+#ifndef _ORINOCO_MONITOR_H
+#define _ORINOCO_MONITOR_H
+
+#ifndef ETH_P_ECONET
+#define ETH_P_ECONET   0x0018    /* needed for 2.2.x kernels */
+#endif
+
+#define ETH_P_80211_RAW        (ETH_P_ECONET + 1)
+
+#ifndef ARPHRD_IEEE80211
+#define ARPHRD_IEEE80211 801     /* kernel 2.4.6 */
+#endif
+
+#ifndef ARPHRD_IEEE80211_PRISM  /* kernel 2.4.18 */
+#define ARPHRD_IEEE80211_PRISM 802
+#endif
+
+#define WLAN_DEVNAMELEN_MAX 16
+
+/* message data item for INT, BOUNDEDINT, ENUMINT */
+typedef struct p80211item_uint32
+{
+	uint32_t		did		__attribute__ ((packed));
+	uint16_t		status	__attribute__ ((packed));
+	uint16_t		len		__attribute__ ((packed));
+	uint32_t		data	__attribute__ ((packed));
+} __attribute__ ((packed)) p80211item_uint32_t;
+
+typedef struct p80211msg
+{
+	uint32_t	msgcode		__attribute__ ((packed));
+	uint32_t	msglen		__attribute__ ((packed));
+	uint8_t	devname[WLAN_DEVNAMELEN_MAX]	__attribute__ ((packed));
+} __attribute__ ((packed)) p80211msg_t;
+
+#define DIDmsg_lnxind_wlansniffrm 0x0041
+#define DIDmsg_lnxind_wlansniffrm_hosttime 0x1041
+#define DIDmsg_lnxind_wlansniffrm_mactime 0x2041
+#define DIDmsg_lnxind_wlansniffrm_channel 0x3041
+#define DIDmsg_lnxind_wlansniffrm_rssi 0x4041
+#define DIDmsg_lnxind_wlansniffrm_sq 0x5041
+#define DIDmsg_lnxind_wlansniffrm_signal 0x6041
+#define DIDmsg_lnxind_wlansniffrm_noise 0x7041
+#define DIDmsg_lnxind_wlansniffrm_rate 0x8041
+#define DIDmsg_lnxind_wlansniffrm_istx 0x9041
+#define DIDmsg_lnxind_wlansniffrm_frmlen 0xA041
+
+typedef struct p80211msg_lnxind_wlansniffrm
+{
+	uint32_t		msgcode;
+	uint32_t		msglen;
+	uint8_t		    devname[WLAN_DEVNAMELEN_MAX];
+	p80211item_uint32_t	hosttime;
+	p80211item_uint32_t	mactime;
+	p80211item_uint32_t	channel;
+	p80211item_uint32_t	rssi;
+	p80211item_uint32_t	sq;
+	p80211item_uint32_t	signal;
+	p80211item_uint32_t	noise;
+	p80211item_uint32_t	rate;
+	p80211item_uint32_t	istx;
+	p80211item_uint32_t	frmlen;
+} __attribute__ ((packed)) p80211msg_lnxind_wlansniffrm_t;
+
+#define P80211ENUM_truth_false			0
+#define P80211ENUM_truth_true			1
+#define P80211ENUM_resultcode_success		1
+#define P80211ENUM_resultcode_invalid_parameters	2
+#define P80211ENUM_resultcode_not_supported	3
+#define P80211ENUM_resultcode_timeout		4
+#define P80211ENUM_resultcode_too_many_req	5
+#define P80211ENUM_resultcode_refused		6
+#define P80211ENUM_resultcode_bss_already	7
+#define P80211ENUM_resultcode_invalid_access	8
+#define P80211ENUM_resultcode_invalid_mibattribute	9
+#define P80211ENUM_resultcode_cant_set_readonly_mib	10
+#define P80211ENUM_resultcode_implementation_failure	11
+#define P80211ENUM_resultcode_cant_get_writeonly_mib	12
+#define P80211ENUM_msgitem_status_data_ok		0
+#define P80211ENUM_msgitem_status_no_value		1
+#define P80211ENUM_msgitem_status_invalid_itemname	2
+#define P80211ENUM_msgitem_status_invalid_itemdata	3
+#define P80211ENUM_msgitem_status_missing_itemdata	4
+#define P80211ENUM_msgitem_status_incomplete_itemdata	5
+#define P80211ENUM_msgitem_status_invalid_msg_did	6
+#define P80211ENUM_msgitem_status_invalid_mib_did	7
+#define P80211ENUM_msgitem_status_missing_conv_func	8
+#define P80211ENUM_msgitem_status_string_too_long	9
+#define P80211ENUM_msgitem_status_data_out_of_range	10
+#define P80211ENUM_msgitem_status_string_too_short	11
+#define P80211ENUM_msgitem_status_missing_valid_func	12
+#define P80211ENUM_msgitem_status_unknown		13
+#define P80211ENUM_msgitem_status_invalid_did		14
+#define P80211ENUM_msgitem_status_missing_print_func	15
+
+#define WLAN_GET_FC_FTYPE(n)	(((n) & 0x0C) >> 2)
+#define WLAN_GET_FC_FSTYPE(n)	(((n) & 0xF0) >> 4)
+#define WLAN_GET_FC_TODS(n) 	(((n) & 0x0100) >> 8)
+#define WLAN_GET_FC_FROMDS(n)	(((n) & 0x0200) >> 9)
+
+/*--- Sizes -----------------------------------------------*/
+#define WLAN_ADDR_LEN			6
+#define WLAN_CRC_LEN			4
+#define WLAN_BSSID_LEN			6
+#define WLAN_BSS_TS_LEN			8
+#define WLAN_HDR_A3_LEN			24
+#define WLAN_HDR_A4_LEN			30
+#define WLAN_SSID_MAXLEN		32
+#define WLAN_DATA_MAXLEN		2312
+
+/*--- Frame Control Field -------------------------------------*/
+/* Frame Types */
+#define WLAN_FTYPE_MGMT			0x00
+#define WLAN_FTYPE_CTL			0x01
+#define WLAN_FTYPE_DATA			0x02
+
+/* Frame subtypes */
+/* Management */
+#define WLAN_FSTYPE_ASSOCREQ		0x00
+#define WLAN_FSTYPE_ASSOCRESP		0x01
+#define WLAN_FSTYPE_REASSOCREQ		0x02
+#define WLAN_FSTYPE_REASSOCRESP		0x03
+#define WLAN_FSTYPE_PROBEREQ		0x04 
+#define WLAN_FSTYPE_PROBERESP		0x05
+#define WLAN_FSTYPE_BEACON		0x08
+#define WLAN_FSTYPE_ATIM		0x09
+#define WLAN_FSTYPE_DISASSOC		0x0a
+#define WLAN_FSTYPE_AUTHEN		0x0b
+#define WLAN_FSTYPE_DEAUTHEN		0x0c
+
+/* Control */
+#define WLAN_FSTYPE_PSPOLL		0x0a
+#define WLAN_FSTYPE_RTS			0x0b
+#define WLAN_FSTYPE_CTS			0x0c
+#define WLAN_FSTYPE_ACK			0x0d
+#define WLAN_FSTYPE_CFEND		0x0e
+#define WLAN_FSTYPE_CFENDCFACK		0x0f
+
+/* Data */
+#define WLAN_FSTYPE_DATAONLY		0x00
+#define WLAN_FSTYPE_DATA_CFACK		0x01
+#define WLAN_FSTYPE_DATA_CFPOLL		0x02
+#define WLAN_FSTYPE_DATA_CFACK_CFPOLL	0x03
+#define WLAN_FSTYPE_NULL		0x04
+#define WLAN_FSTYPE_CFACK		0x05
+#define WLAN_FSTYPE_CFPOLL		0x06
+#define WLAN_FSTYPE_CFACK_CFPOLL	0x07
+
+/*----------------------------------------------------------------*/
+/* Magic number, a quick test to see we're getting the desired struct */
+
+#define P80211_IOCTL_MAGIC	(0x4a2d464dUL)
+
+typedef struct p80211ioctl_req
+{
+	char 	name[WLAN_DEVNAMELEN_MAX] __attribute__ ((packed));
+	void	*data 		__attribute__ ((packed));
+	uint32_t	magic 	__attribute__ ((packed));
+	uint16_t	len 	__attribute__ ((packed));
+	uint32_t	result 	__attribute__ ((packed));
+} __attribute__ ((packed)) p80211ioctl_req_t;
+
+#endif /* _ORINOCO_MONITOR_H */
diff -Nru pcmcia-cs-3.2.8.orig/wireless/orinoco.c pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco.c
--- pcmcia-cs-3.2.8.orig/wireless/orinoco.c	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco.c	2006-03-18 16:27:20.000000000 +0100
@@ -1,4 +1,4 @@
-/* orinoco.c 0.13e	- (formerly known as dldwd_cs.c and orinoco_cs.c)
+/* orinoco.c 0.13b	- (formerly known as dldwd_cs.c and orinoco_cs.c)
  *
  * A driver for Hermes or Prism 2 chipset based PCMCIA wireless
  * adaptors, with Lucent/Agere, Intersil or Symbol firmware.
@@ -8,11 +8,15 @@
  * Copyright (C) 2001 Jean Tourrilhes, HP Labs <jt@hpl.hp.com>
  * Copyright (C) 2001 Benjamin Herrenschmidt <benh@kernel.crashing.org>
  *
+ *
  * Based on dummy_cs.c 1.27 2000/06/12 21:27:25
  *
  * Portions based on wvlan_cs.c 1.0.6, Copyright Andreas Neuhaus <andy@fasta.fh-dortmund.de>
  *      http://www.fasta.fh-dortmund.de/users/andy/wvlan/
  *
+ * AUX Port stuff Copyright (C) 2003, Benedikt 'Hunz' Heinz <hunz@hunz.org>
+ * (code of David Gibson and Jouni Malinen <jkmaline@cc.hut.fi> also used)
+ *
  * The contents of this file are subject to the Mozilla Public License
  * Version 1.1 (the "License"); you may not use this file except in
  * compliance with the License. You may obtain a copy of the License
@@ -117,7 +121,7 @@
  *	o Init of priv->tx_rate_ctrl in firmware specific section.
  *	o Prism2/Symbol rate, upto should be 0xF and not 0x15. Doh !
  *	o Spectrum card always need cor_reset (for every reset)
- *	o Fix cor_reset to not lose bit 7 in the register
+ *	o Fix cor_reset to not loose bit 7 in the register
  *	o flush_stale_links to remove zombie Pcmcia instances
  *	o Ack previous hermes event before reset
  *		Me (with my little hands)
@@ -289,7 +293,7 @@
  *	  which are used as the dev->open, dev->stop, priv->reset
  *	  callbacks if none are specified when alloc_orinocodev() is
  *	  called.
- *	o Removed orinoco_plx_interrupt() and orinoco_pci_interrupt().
+ *	o Removed orinoco_plx_interupt() and orinoco_pci_interrupt().
  *	  They didn't do anything.
  *
  * v0.12 -> v0.12a - 4 Jul 2002 - David Gibson
@@ -345,54 +349,37 @@
  * 	  we are connected (avoids cofusing the firmware), and only
  * 	  give LINKSTATUS printk()s if the status has changed.
  *
+ * v0.13b-hermesap-0.1a - 21 Feb 2003 - Hunz
+ *  o AUX Port support via mem_dev device added for firmware
+ *    up- and download
+ *  o modifications for AP (BSS master) mode
+ *  o modified ipwriv dump_recs to also dump unknown RIDs
+ *  o added set_mac
+ *
  * v0.13b -> v0.13c - 11 Mar 2003 - David Gibson
- *	o Cleanup: use dev instead of priv in various places.
- *	o Bug fix: Don't ReleaseConfiguration on RESET_PHYSICAL event
- *	  if we're in the middle of a (driver initiated) hard reset.
- *	o Bug fix: ETH_ZLEN is supposed to include the header
- *	  (Dionysus Blazakis & Manish Karir)
- *	o Convert to using workqueues instead of taskqueues (and
- *	  backwards compatibility macros for pre 2.5.41 kernels).
- *	o Drop redundant (I think...) MOD_{INC,DEC}_USE_COUNT in
- *	  airport.c
- *	o New orinoco_tmd.c init module from Joerg Dorchain for
- *	  TMD7160 based PCI to PCMCIA bridges (similar to
- *	  orinoco_plx.c).
- *
- * v0.13c -> v0.13d - 22 Apr 2003 - David Gibson
- *	o Make hw_unavailable a counter, rather than just a flag, this
- *	  is necessary to avoid some races (such as a card being
- *	  removed in the middle of orinoco_reset().
- *	o Restore Release/RequestConfiguration in the PCMCIA event handler
- *	  when dealing with a driver initiated hard reset.  This is
- *	  necessary to prevent hangs due to a spurious interrupt while
- *	  the reset is in progress.
- *	o Clear the 802.11 header when transmitting, even though we
- *	  don't use it.  This fixes a long standing bug on some
- *	  firmwares, which seem to get confused if that isn't done.
- *	o Be less eager to de-encapsulate SNAP frames, only do so if
- *	  the OUI is 00:00:00 or 00:00:f8, leave others alone.  The old
- *	  behaviour broke CDP (Cisco Discovery Protocol).
- *	o Use dev instead of priv for free_irq() as well as
- *	  request_irq() (oops).
- *	o Attempt to reset rather than giving up if we get too many
- *	  IRQs.
- *	o Changed semantics of __orinoco_down() so it can be called
- *	  safely with hw_unavailable set.  It also now clears the
- *	  linkstatus (since we're going to have to reassociate).
- *
- * v0.13d -> v0.13e - 12 May 2003 - David Gibson
- *	o Support for post-2.5.68 return values from irq handler.
- *	o Fixed bug where underlength packets would be double counted
- *	  in the rx_dropped statistics.
- *	o Provided a module parameter to suppress linkstatus messages.
+ *     o Cleanup: use dev instead of priv in various places.
+ *     o Bug fix: Don't ReleaseConfiguration on RESET_PHYSICAL event
+ *       if we're in the middle of a (driver initiated) hard reset.
+ *     o Bug fix: ETH_ZLEN is supposed to include the header
+ *       (Dionysus Blazakis & Manish Karir)
+ *     o Convert to using workqueues instead of taskqueues (and
+ *       backwards compatibility macros for pre 2.5.41 kernels).
+ *     o Drop redundant (I think...) MOD_{INC,DEC}_USE_COUNT in
+ *       airport.c
+ *     o New orinoco_tmd.c init module from Joerg Dorchain for
+ *       TMD7160 based PCI to PCMCIA bridges (similar to
+ *       orinoco_plx.c).
+ *
+ * v0.13c-nodevfs -- Sat, 18 Mar 2006 15:21:29 +0100  Karol Lewandowski
+ *     o remove devfs usage -- switch to private character device for
+ *       firmware updates
  *
  * TODO
  *	o New wireless extensions API (patch from Moustafa
- *	  Youssef, updated by Jim Carter and Pavel Roskin).
+ *	  Youssef, updated by Jim Carter).
+ *	o Fix PCMCIA hard resets with pcmcia-cs.
  *	o Handle de-encapsulation within network layer, provide 802.11
  *	  headers (patch from Thomas 'Dent' Mirlacher)
- *	o RF monitor mode support
  *	o Fix possible races in SPY handling.
  *	o Disconnect wireless extensions from fundamental configuration.
  *	o (maybe) Software WEP support (patch from Stano Meduna).
@@ -414,31 +401,35 @@
  * flag after taking the lock, and if it is set, give up on whatever
  * they are doing and drop the lock again.  The orinoco_lock()
  * function handles this (it unlocks and returns -EBUSY if
- * hw_unavailable is non-zero). */
+ * hw_unavailable is true). */
 
 #include <linux/config.h>
 
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/sched.h>
 #include <linux/ptrace.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/system.h>
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
 #include <linux/etherdevice.h>
 #include <linux/wireless.h>
 
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/system.h>
+/* for mem_dev */
+#include <linux/autoconf.h>
 
 #include "hermes.h"
 #include "hermes_rid.h"
 #include "orinoco.h"
 #include "ieee802_11.h"
+#include "monitor.h"
 
 /********************************************************************/
 /* Module information                                               */
@@ -457,9 +448,6 @@
 EXPORT_SYMBOL(orinoco_debug);
 #endif
 
-static int suppress_linkstatus; /* = 0 */
-MODULE_PARM(suppress_linkstatus, "i");
-
 /********************************************************************/
 /* Compile time configuration and compatibility stuff               */
 /********************************************************************/
@@ -468,9 +456,6 @@
 #ifndef SIOCIWFIRSTPRIV
 #define SIOCIWFIRSTPRIV		SIOCDEVPRIVATE
 #endif /* SIOCIWFIRSTPRIV */
-#ifndef SIOCIWLASTPRIV
-#define SIOCIWLASTPRIV		SIOCDEVPRIVATE+0xF
-#endif /* SIOCIWLASTPRIV */
 
 /* We do this this way to avoid ifdefs in the actual code */
 #ifdef WIRELESS_SPY
@@ -490,16 +475,12 @@
 #define USER_BAP		0
 #define IRQ_BAP			1
 #define MAX_IRQLOOPS_PER_IRQ	10
-#define MAX_IRQLOOPS_PER_JIFFY	(20000/HZ) /* Based on a guestimate of
-					    * how many events the
-					    * device could
-					    * legitimately generate */
+#define MAX_IRQLOOPS_PER_JIFFY	(20000/HZ)	/* Based on a guestimate of how many events the
+						   device could legitimately generate */
 #define SMALL_KEY_SIZE		5
 #define LARGE_KEY_SIZE		13
 #define TX_NICBUF_SIZE_BUG	1585		/* Bug in Symbol firmware */
 
-#define DUMMY_FID		0xFFFF
-
 #define RUP_EVEN(a) (((a) + 1) & (~1))
 
 /*#define MAX_MULTICAST(priv)	(priv->firmware_type == FIRMWARE_TYPE_AGERE ? \
@@ -529,8 +510,8 @@
 	{10,  1,  1,  1},
 	{20,  0,  2,  2},
 	{20,  1,  6,  3},
-	{55,  0,  4,  4},
-	{55,  1,  7,  7},
+	{55, 0,  4,  4},
+	{55, 1,  7,  7},
 	{110, 0,  5,  8},
 };
 #define BITRATE_TABLE_SIZE (sizeof(bitrate_table) / sizeof(bitrate_table[0]))
@@ -562,6 +543,8 @@
 /* Function prototypes                                              */
 /********************************************************************/
 
+static int orinoco_init(struct net_device *dev);
+
 static void orinoco_stat_gather(struct net_device *dev,
 				struct sk_buff *skb,
 				struct hermes_rx_descriptor *desc);
@@ -583,80 +566,176 @@
 				      s32 *rates, int max);
 static void __orinoco_set_multicast_list(struct net_device *dev);
 
+static int orinoco_hw_monitor(struct net_device *dev);
+
 /* Interrupt handling routines */
 static void __orinoco_ev_tick(struct net_device *dev, hermes_t *hw);
 static void __orinoco_ev_wterr(struct net_device *dev, hermes_t *hw);
 static void __orinoco_ev_infdrop(struct net_device *dev, hermes_t *hw);
 static void __orinoco_ev_info(struct net_device *dev, hermes_t *hw);
 static void __orinoco_ev_rx(struct net_device *dev, hermes_t *hw);
+
+void orinoco_int_rxmonitor( struct net_device *dev, uint16_t rxfid, int len,
+                            struct hermes_rx_descriptor *rxdesc, struct ieee802_11_hdr *hdr);
+
 static void __orinoco_ev_txexc(struct net_device *dev, hermes_t *hw);
 static void __orinoco_ev_tx(struct net_device *dev, hermes_t *hw);
 static void __orinoco_ev_alloc(struct net_device *dev, hermes_t *hw);
 
 /* ioctl() routines */
-static int orinoco_debug_dump_recs(struct net_device *dev);
+static int orinoco_ioctl_getiwrange(struct net_device *dev, struct iw_point *rrq);
+static int orinoco_ioctl_setiwencode(struct net_device *dev, struct iw_point *erq);
+static int orinoco_ioctl_getiwencode(struct net_device *dev, struct iw_point *erq);
+static int orinoco_ioctl_setessid(struct net_device *dev, struct iw_point *erq);
+static int orinoco_ioctl_getessid(struct net_device *dev, struct iw_point *erq);
+static int orinoco_ioctl_setnick(struct net_device *dev, struct iw_point *nrq);
+static int orinoco_ioctl_getnick(struct net_device *dev, struct iw_point *nrq);
+static int orinoco_ioctl_setfreq(struct net_device *dev, struct iw_freq *frq);
+static int orinoco_ioctl_getsens(struct net_device *dev, struct iw_param *srq);
+static int orinoco_ioctl_setsens(struct net_device *dev, struct iw_param *srq);
+static int orinoco_ioctl_setrts(struct net_device *dev, struct iw_param *rrq);
+static int orinoco_ioctl_setfrag(struct net_device *dev, struct iw_param *frq);
+static int orinoco_ioctl_getfrag(struct net_device *dev, struct iw_param *frq);
+static int orinoco_ioctl_setrate(struct net_device *dev, struct iw_param *frq);
+static int orinoco_ioctl_getrate(struct net_device *dev, struct iw_param *frq);
+static int orinoco_ioctl_setpower(struct net_device *dev, struct iw_param *prq);
+static int orinoco_ioctl_getpower(struct net_device *dev, struct iw_param *prq);
+static int orinoco_ioctl_setport3(struct net_device *dev, struct iwreq *wrq);
+static int orinoco_ioctl_getport3(struct net_device *dev, struct iwreq *wrq);
+
+static int orinoco_debug_dump_rids(struct orinoco_private *priv);
+
+/* memdev stuff */
+static int orinoco_mem_ioctl (struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int orinoco_mem_open (struct inode *inode, struct file *file);
+static ssize_t orinoco_mem_write (struct file *file, const char *buf, size_t count, loff_t *offset);
+static ssize_t orinoco_mem_read (struct file *file, char *buf, size_t count, loff_t *offset);
+static loff_t orinoco_mem_llseek (struct file *filp, loff_t off, int whence);
+static int orinoco_mem_close(struct inode *inode, struct file *file);
+
+static struct file_operations orinoco_mem_fops = {
+        owner:          THIS_MODULE,
+        read:           orinoco_mem_read,
+        write:          orinoco_mem_write,
+	llseek:		orinoco_mem_llseek,
+        ioctl:          orinoco_mem_ioctl,
+        open:           orinoco_mem_open,
+        release:        orinoco_mem_close,
+};
+
+#define ORINOCO_MAX_DEVICES 16
+#define ORINOCO_MAJOR 250
+#define ORINOCO_DEVNAME "orinoco_mem"
+static void *orinoco_dev_priv[ORINOCO_MAX_DEVICES];
 
 /********************************************************************/
 /* Function prototypes                                              */
 /********************************************************************/
 
-int __orinoco_up(struct net_device *dev)
-{
+int __orinoco_up(struct net_device *dev) {
 	struct orinoco_private *priv = dev->priv;
 	struct hermes *hw = &priv->hw;
-	int err;
+	int err, port=orinoco_lookup_port(dev);
 
-	err = __orinoco_program_rids(dev);
-	if (err) {
-		printk(KERN_ERR "%s: Error %d configuring card\n",
-		       dev->name, err);
-		return err;
-	}
+	if((port<0) || (port>WDS_PORTS))
+		return -EINVAL;
+	
+	if(dev->type == ARPHRD_ETHER) {
+		err = __orinoco_program_rids(dev);
+		if (err) {
+			printk(KERN_ERR "%s: Error %d configuring card\n",
+				   dev->name, err);
+			return err;
+		}
 
-	/* Fire things up again */
-	hermes_set_irqmask(hw, ORINOCO_INTEN);
-	err = hermes_enable_port(hw, 0);
-	if (err) {
-		printk(KERN_ERR "%s: Error %d enabling MAC port\n",
-		       dev->name, err);
-		return err;
+		/* If 1st port to enable -> Fire things up again */
+		if((priv->open) ^ (orinoco_wds_active(priv)==1))
+			hermes_set_irqmask(hw, ORINOCO_INTEN);
+	
+		err = hermes_enable_port(hw, port);
+		if (err) {
+			printk(KERN_ERR "%s: Error %d enabling MAC port %d\n",
+				   dev->name, err, port);
+			return err;
+		}
+	}
+	else { /* monitoring */
+		err = orinoco_hw_monitor(dev);
+		if (err) {
+			printk(KERN_ERR "%s: Error %d configuring monitoring\n",
+				   dev->name, err);
+			return err;
+		}
 	}
 
 	netif_start_queue(dev);
-	netif_mark_up(dev);
 
 	return 0;
 }
 
-int __orinoco_down(struct net_device *dev)
-{
+int __orinoco_down(struct net_device *dev) {
 	struct orinoco_private *priv = dev->priv;
 	struct hermes *hw = &priv->hw;
-	int err;
+	int err, port=orinoco_lookup_port(dev);
 
+	if((port<0) || (port>WDS_PORTS))
+		return -EINVAL;
+	
 	netif_stop_queue(dev);
-        netif_mark_down(dev);
 
-	if (! priv->hw_unavailable) {
-		if (! priv->broken_disableport) {
-			err = hermes_disable_port(hw, 0);
-			if (err) {
-				/* Some firmwares (e.g. Intersil 1.3.x) seem
-				 * to have problems disabling the port, oh
-				 * well, too bad. */
-				printk(KERN_WARNING "%s: Error %d disabling MAC port\n",
-				       dev->name, err);
-				priv->broken_disableport = 1;
-			}
+	if(dev->type == ARPHRD_ETHER) {
+		err = hermes_disable_port(hw, port);
+		if (err) {
+			printk(KERN_ERR "%s: Error %d disabling MAC port %d\n",
+				   dev->name, err, port);
+			return err;
+		}
+	
+		if((!(priv->open)) && (!(orinoco_wds_active(priv)))) {
+			hermes_set_irqmask(hw, 0);
+			hermes_write_regn(hw, EVACK, 0xffff);
 		}
-		hermes_set_irqmask(hw, 0);
-		hermes_write_regn(hw, EVACK, 0xffff);
+	}
+	else { /* monitoring */
+		err=hermes_init(hw);
+		return err;
 	}
 	
-	/* firmware will have to reassociate */
-	priv->last_linkstatus = 0xffff;
-	priv->connected = 0;
+	return 0;
+}
 
+int orinoco_alloc_txfids(struct orinoco_private *priv, int num) {
+	struct hermes *hw = &priv->hw;
+	int err, tries=num<<1;
+	u16 fid;
+	
+	if(num>ORINOCO_TXFIDS) {
+		printk(KERN_WARNING"orinoco: DRIVER BUG! Can't alloc %d TxFids (max %d)\n",num,ORINOCO_TXFIDS);
+		num=ORINOCO_TXFIDS;
+	}
+	
+	for(priv->txfids=0; (priv->txfids<num) && (tries); tries--) {
+		fid=0;
+		err = hermes_allocate(hw, priv->nicbuf_size, &fid);
+		if (err == -EIO) {
+			/* Try workaround for old Symbol firmware bug */
+			printk(KERN_WARNING "%s: firmware ALLOC bug detected "
+				   "(old Symbol firmware?). Trying to work around... ",
+				   priv->ndev->name);
+		
+			priv->nicbuf_size = TX_NICBUF_SIZE_BUG;
+			err = hermes_allocate(hw, priv->nicbuf_size, &fid);
+			if (err) {
+				printk("failed!\n");
+				return err;
+			}
+		} /* EIO */
+		else if(err)
+			return err;
+		if((fid) && (fid!=ORINOCO_DUMMY_FID))
+			priv->txfid[priv->txfids++]=fid;
+	} /* for */
+	
 	return 0;
 }
 
@@ -666,26 +745,23 @@
 	struct hermes *hw = &priv->hw;
 	int err;
 
+	priv->txfids=0;
 	err = hermes_init(hw);
 	if (err)
 		return err;
 
-	err = hermes_allocate(hw, priv->nicbuf_size, &priv->txfid);
-	if (err == -EIO) {
-		/* Try workaround for old Symbol firmware bug */
-		printk(KERN_WARNING "%s: firmware ALLOC bug detected "
-		       "(old Symbol firmware?). Trying to work around... ",
-		       dev->name);
-		
-		priv->nicbuf_size = TX_NICBUF_SIZE_BUG;
-		err = hermes_allocate(hw, priv->nicbuf_size, &priv->txfid);
-		if (err)
-			printk("failed!\n");
-		else
-			printk("ok.\n");
+	err=orinoco_alloc_txfids(priv, ORINOCO_TXFIDS);
+	if(err)
+		return err;
+	
+	if(priv->txfids<=0) {
+		printk(KERN_ERR"orinoco: WAAH! Couldn't alloc any TxFid for %s\n",dev->name);
+		return -EIO;
 	}
-
-	return err;
+	else if(priv->txfids<ORINOCO_TXFIDS)
+		printk(KERN_WARNING"orinoco: Could only alloc %d of %d TxFids\n",err,ORINOCO_TXFIDS);
+	
+	return 0;
 }
 
 static int orinoco_open(struct net_device *dev)
@@ -698,56 +774,75 @@
 	if (err)
 		return err;
 
-	err = __orinoco_up(dev);
-
-	if (! err)
-		priv->open = 1;
+	if(priv->dl_pid) /* firmware upload in progress - reject setup of netdev */
+		err= -EBUSY;
+	else {
+		/* primary */
+		if(dev == priv->ndev)
+			priv->open = 1;
+		else {
+			int port=orinoco_lookup_port(dev);
+			
+			if((port>=1) && (port<=WDS_PORTS))
+				priv->wdslink[port-1].info|=WDS_INFO_OPEN;
+			else { /* shouldn't happen... */
+				err = -EINVAL;
+				goto out;
+			}
+		}
 
+		err = __orinoco_up(dev);
+	}
+	out:
 	orinoco_unlock(priv, &flags);
 
 	return err;
 }
 
-int orinoco_stop(struct net_device *dev)
+static int orinoco_stop(struct net_device *dev)
 {
 	struct orinoco_private *priv = dev->priv;
 	int err = 0;
 
 	/* We mustn't use orinoco_lock() here, because we need to be
-	   able to close the interface even if hw_unavailable is set
+	   able to close the interface, even if hw_unavailable is set
 	   (e.g. as we're released after a PC Card removal) */
 	spin_lock_irq(&priv->lock);
 
-	priv->open = 0;
+	if(dev == priv->ndev)
+		priv->open = 0;
+	else {
+		int port=orinoco_lookup_port(dev);
+		
+		if((port>=1) && (port<=WDS_PORTS))
+			priv->wdslink[port-1].info&=~WDS_INFO_OPEN;
+		else { /* shouldn't happen... */
+			err = -EINVAL;
+			goto out;
+		}
+	}
 
-	err = __orinoco_down(dev);
+	if (! priv->hw_unavailable)
+		err = __orinoco_down(dev);
 
+	out:
 	spin_unlock_irq(&priv->lock);
 
 	return err;
 }
 
-static int __orinoco_program_rids(struct net_device *dev)
-{
+static int __orinoco_program_rids(struct net_device *dev) {
 	struct orinoco_private *priv = dev->priv;
 	hermes_t *hw = &priv->hw;
 	int err;
 	struct hermes_idstring idbuf;
 
-	/* Set the MAC address */
-	err = hermes_write_ltv(hw, USER_BAP, HERMES_RID_CNFOWNMACADDR,
-			       HERMES_BYTES_TO_RECLEN(ETH_ALEN), dev->dev_addr);
-	if (err) {
-		printk(KERN_ERR "%s: Error %d setting MAC address\n", dev->name, err);
-		return err;
-	}
+	/* AP & !AP mode */
+	
+	/* Set promiscuity / multicast*/
+	priv->promiscuous = 0;
+	priv->mc_count = 0;
 
-	/* Set up the link mode */
-	err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFPORTTYPE, priv->port_type);
-	if (err) {
-		printk(KERN_ERR "%s: Error %d setting port type\n", dev->name, err);
-		return err;
-	}
 	/* Set the channel/frequency */
 	if (priv->channel == 0) {
 		printk(KERN_DEBUG "%s: Channel is 0 in __orinoco_program_rids()\n", dev->name);
@@ -759,44 +854,17 @@
 		printk(KERN_ERR "%s: Error %d setting channel\n", dev->name, err);
 		return err;
 	}
-
-	if (priv->has_ibss) {
-		err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFCREATEIBSS,
-					   priv->createibss);
+	
+	/* Set up encryption */
+	if (priv->has_wep) {
+		err = __orinoco_hw_setup_wep(priv);
 		if (err) {
-			printk(KERN_ERR "%s: Error %d setting CREATEIBSS\n", dev->name, err);
+			printk(KERN_ERR "%s: Error %d activating WEP\n",
+			       dev->name, err);
 			return err;
 		}
-
-		if ((strlen(priv->desired_essid) == 0) && (priv->createibss)
-		   && (!priv->has_ibss_any)) {
-			printk(KERN_WARNING "%s: This firmware requires an \
-ESSID in IBSS-Ad-Hoc mode.\n", dev->name);
-			/* With wvlan_cs, in this case, we would crash.
-			 * hopefully, this driver will behave better...
-			 * Jean II */
-		}
-	}
-
-	/* Set the desired ESSID */
-	idbuf.len = cpu_to_le16(strlen(priv->desired_essid));
-	memcpy(&idbuf.val, priv->desired_essid, sizeof(idbuf.val));
-	/* WinXP wants partner to configure OWNSSID even in IBSS mode. (jimc) */
-	err = hermes_write_ltv(hw, USER_BAP, HERMES_RID_CNFOWNSSID,
-			       HERMES_BYTES_TO_RECLEN(strlen(priv->desired_essid)+2),
-			       &idbuf);
-	if (err) {
-		printk(KERN_ERR "%s: Error %d setting OWNSSID\n", dev->name, err);
-		return err;
-	}
-	err = hermes_write_ltv(hw, USER_BAP, HERMES_RID_CNFDESIREDSSID,
-			       HERMES_BYTES_TO_RECLEN(strlen(priv->desired_essid)+2),
-			       &idbuf);
-	if (err) {
-		printk(KERN_ERR "%s: Error %d setting DESIREDSSID\n", dev->name, err);
-		return err;
 	}
-
+	
 	/* Set the station name */
 	idbuf.len = cpu_to_le16(strlen(priv->nick));
 	memcpy(&idbuf.val, priv->nick, sizeof(idbuf.val));
@@ -820,13 +888,6 @@
 		}
 	}
 
-	/* Set RTS threshold */
-	err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFRTSTHRESHOLD, priv->rts_thresh);
-	if (err) {
-		printk(KERN_ERR "%s: Error %d setting RTS threshold\n", dev->name, err);
-		return err;
-	}
-
 	/* Set fragmentation threshold or MWO robustness */
 	if (priv->has_mwo)
 		err = hermes_write_wordrec(hw, USER_BAP,
@@ -840,21 +901,132 @@
 		printk(KERN_ERR "%s: Error %d setting framentation\n", dev->name, err);
 		return err;
 	}
-
+	
 	/* Set bitrate */
 	err = __orinoco_hw_set_bitrate(priv);
 	if (err) {
 		printk(KERN_ERR "%s: Error %d setting bitrate\n", dev->name, err);
 		return err;
 	}
+	
+	/* Set the ESSID */
+	idbuf.len = cpu_to_le16(strlen(priv->desired_essid));
+	memcpy(&idbuf.val, priv->desired_essid, sizeof(idbuf.val));
+	/* WinXP wants partner to configure OWNSSID even in IBSS mode. (jimc) */
+	err = hermes_write_ltv(hw, USER_BAP, HERMES_RID_CNFOWNSSID,
+			       HERMES_BYTES_TO_RECLEN(strlen(priv->desired_essid)+2),
+			       &idbuf);
+	if (err) {
+		printk(KERN_ERR "%s: Error %d setting OWNSSID\n", dev->name, err);
+		return err;
+	}
+	
+	if(priv->ap_mode) {
+		int port;
+		/* BSS creation */
+		
+		/* Set RTS threshold */
+		err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFRTSTHRESHOLD, 
+				priv->rts_thresh);
+		/* we ignore err here since old firmwares (T6.14 for example)
+		   just don't have this register - but that doesn't matter */
+		err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFRTSTHRESHOLD0, 
+				priv->rts_thresh);
+		if (err)
+			return err;
+		
+		/* WDS stuff */
+		for(port=0; port<WDS_PORTS; port++) {
+			
+				/* peer mac */
+				err = hermes_write_ltv(hw, USER_BAP, HERMES_RID_CNFWDSADDRESS1+port,
+					   HERMES_BYTES_TO_RECLEN(ETH_ALEN), priv->wdslink[port].peer_addr);
+				if(err)
+					return err;
+				
+				/* RTS threshold */
+				err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFRTSTHRESHOLD1+port, 
+						priv->wdslink[port].rts_thres);
+				if(err)
+					return err;
+		}
+		
+		/* hidden mode */
+		err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFHIDDENMODE, 
+					(priv->ap_mode&ORINOCO_AP_HIDDEN)>>1);
+		return err;
+		
+	} /* BSS master */
+	
+	/* STA */
+	/* set the desired ESSID */
+	err = hermes_write_ltv(hw, USER_BAP, HERMES_RID_CNFDESIREDSSID,
+				   HERMES_BYTES_TO_RECLEN(strlen(priv->desired_essid)+2),
+				   &idbuf);
+	if (err) {
+		printk(KERN_ERR "%s: Error %d setting DESIREDSSID\n", dev->name, err);
+		return err;
+	}
+	
+	/* Set RTS threshold */
+	err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFRTSTHRESHOLD, priv->rts_thresh);
+	if (err) {
+		printk(KERN_ERR "%s: Error %d setting RTS threshold\n", dev->name, err);
+		return err;
+	}
+
+	/* Set the MAC address */
+	err = hermes_write_ltv(hw, USER_BAP, HERMES_RID_CNFOWNMACADDR,
+				   HERMES_BYTES_TO_RECLEN(ETH_ALEN), dev->dev_addr);
+	if (err) {
+		printk(KERN_ERR "%s: Error %d setting MAC address\n", dev->name, err);
+		return err;
+	}
+
+	/* Set up the link mode */
+	err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFPORTTYPE, priv->port_type);
+	if (err) {
+		printk(KERN_ERR "%s: Error %d setting port type\n", dev->name, err);
+		return err;
+	}
+
+	if (priv->has_ibss) {
+		err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFCREATEIBSS,
+					   priv->createibss);
+		if (err) {
+			printk(KERN_ERR "%s: Error %d setting CREATEIBSS\n", dev->name, err);
+			return err;
+		}
+
+		if ((strlen(priv->desired_essid) == 0) && (priv->createibss)
+		   && (!priv->has_ibss_any)) {
+			printk(KERN_WARNING "%s: This firmware requires an \
+SSID in IBSS-Ad-Hoc mode.\n", dev->name);
+			/* With wvlan_cs, in this case, we would crash.
+			 * hopefully, this driver will behave better...
+			 * Jean II */
+		}
+	}
 
+	/* Set preamble - only for Symbol so far... */
+	if (priv->has_preamble) {
+		err = hermes_write_wordrec(hw, USER_BAP,
+					   HERMES_RID_CNFPREAMBLE_SYMBOL,
+					   priv->preamble);
+		if (err) {
+			printk(KERN_ERR "%s: Error %d setting preamble\n",
+				   dev->name, err);
+			return err;
+		}
+	}
+	
 	/* Set power management */
 	if (priv->has_pm) {
 		err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFPMENABLED,
 					   priv->pm_on);
 		if (err) {
 			printk(KERN_ERR "%s: Error %d setting up PM\n",
-			       dev->name, err);
+				   dev->name, err);
 			return err;
 		}
 
@@ -863,7 +1035,7 @@
 					   priv->pm_mcast);
 		if (err) {
 			printk(KERN_ERR "%s: Error %d setting up PM\n",
-			       dev->name, err);
+				   dev->name, err);
 			return err;
 		}
 		err = hermes_write_wordrec(hw, USER_BAP,
@@ -871,7 +1043,7 @@
 					   priv->pm_period);
 		if (err) {
 			printk(KERN_ERR "%s: Error %d setting up PM\n",
-			       dev->name, err);
+				   dev->name, err);
 			return err;
 		}
 		err = hermes_write_wordrec(hw, USER_BAP,
@@ -879,156 +1051,230 @@
 					   priv->pm_timeout);
 		if (err) {
 			printk(KERN_ERR "%s: Error %d setting up PM\n",
-			       dev->name, err);
+				   dev->name, err);
 			return err;
 		}
 	}
 
-	/* Set preamble - only for Symbol so far... */
-	if (priv->has_preamble) {
-		err = hermes_write_wordrec(hw, USER_BAP,
-					   HERMES_RID_CNFPREAMBLE_SYMBOL,
-					   priv->preamble);
-		if (err) {
-			printk(KERN_ERR "%s: Error %d setting preamble\n",
-			       dev->name, err);
-			return err;
-		}
-	}
+	__orinoco_set_multicast_list(dev); /* FIXME: what about the xmit_lock */
 
-	/* Set up encryption */
-	if (priv->has_wep) {
-		err = __orinoco_hw_setup_wep(priv);
-		if (err) {
-			printk(KERN_ERR "%s: Error %d activating WEP\n",
-			       dev->name, err);
-			return err;
-		}
-	}
-
-	/* Set promiscuity / multicast*/
-	priv->promiscuous = 0;
-	priv->mc_count = 0;
-	__orinoco_set_multicast_list(dev); /* FIXME: what about the xmit_lock */
-
-	return 0;
+	return err;
 }
 
-/* xyzzy */
-static int orinoco_reconfigure(struct net_device *dev)
-{
+static int orinoco_hw_monitor(struct net_device *dev) {
 	struct orinoco_private *priv = dev->priv;
 	struct hermes *hw = &priv->hw;
-	unsigned long flags;
 	int err = 0;
 
-	if (priv->broken_disableport) {
-		schedule_work(&priv->reset_work);
+	if(!(priv->open))
 		return 0;
-	}
+	
+	hermes_set_irqmask(hw, 0);
 
-	err = orinoco_lock(priv, &flags);
-	if (err)
+	priv->txfids=0;
+	err = hermes_init(hw);
+	if(err) {
+		printk(KERN_ERR "%s: (monitor) Error %d resetting card\n", dev->name, err);
 		return err;
-
-		
-	err = hermes_disable_port(hw, 0);
+	}
+	
+	hermes_set_irqmask(hw, HERMES_EV_RX);
+	
+	err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFOWNCHANNEL, priv->channel);
 	if (err) {
-		printk(KERN_WARNING "%s: Unable to disable port while reconfiguring card\n",
-		       dev->name);
-		priv->broken_disableport = 1;
-		goto out;
+		printk(KERN_ERR "%s: (monitor) Error %d setting channel\n", dev->name, err);
+		return err;
 	}
-
-	err = __orinoco_program_rids(dev);
+	
+	err = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFPORTTYPE, 3);
 	if (err) {
-		printk(KERN_WARNING "%s: Unable to reconfigure card\n",
-		       dev->name);
-		goto out;
+		printk(KERN_ERR "%s: (monitor) Error %d setting port type\n", dev->name, err);
+		return err;
 	}
-
+	
 	err = hermes_enable_port(hw, 0);
-	if (err) {
-		printk(KERN_WARNING "%s: Unable to enable port while reconfiguring card\n",
-		       dev->name);
-		goto out;
+	if(err) {
+		printk(KERN_ERR "%s: (monitor) Error %d enabling port\n", dev->name, err);
+		return err;
 	}
-
- out:
-	if (err) {
-		printk(KERN_WARNING "%s: Resetting instead...\n", dev->name);
-		schedule_work(&priv->reset_work);
-		err = 0;
+	
+	err = hermes_docmd_wait(hw, HERMES_CMD_MONITOR | (HERMES_MONITOR_ENABLE << 8), 0, NULL);
+	if(err) {
+		printk(KERN_ERR "%s: (monitor) Error %d enabling monitoring\n", dev->name, err);
+		return err;
 	}
-
-	orinoco_unlock(priv, &flags);
-	return err;
-
+	
+	return 0;
 }
 
-/* This must be called from user context, without locks held - use
- * schedule_work() */
-static void orinoco_reset(struct net_device *dev)
-{
-	struct orinoco_private *priv = dev->priv;
+static int orinoco_hw_reconfigure(struct orinoco_private *priv, int disable) {
+	struct net_device *dev = priv->ndev;
 	struct hermes *hw = &priv->hw;
-	int err;
-	unsigned long flags;
+	int err = 0;
+	int port=0;
+	
+	if(disable) {
+		if(netif_running(dev))
+			err = hermes_disable_port(hw, port);
+		while((!err) && (port<WDS_PORTS)) {
+			port++;
+			if(netif_running(&(priv->wdslink[port-1].dev)))
+				err = hermes_disable_port(hw, port);
+		}
+		if (err) {
+			printk(KERN_ERR "%s: Unable to disable port %d in orinco_reconfigure()\n", dev->name, port);
+			return err;
+		}
+		port=0;
+	}
 
-	err = orinoco_lock(priv, &flags);
+	err = __orinoco_program_rids(dev);
 	if (err)
-		/* When the hardware becomes available again, whatever
-		 * detects that is responsible for re-initializing
-		 * it. So no need for anything further*/
-		return;
-
-	netif_stop_queue(dev);
+		return err;
 
-	/* Shut off interrupts.  Depending on what state the hardware
-	 * is in, this might not work, but we'll try anyway */
-	hermes_set_irqmask(hw, 0);
-	hermes_write_regn(hw, EVACK, 0xffff);
+	if(netif_running(dev))
+		err = hermes_enable_port(hw, port);
+	while((!err) && (port<WDS_PORTS)) {
+		port++;
+		if(netif_running(&(priv->wdslink[port-1].dev)))
+			err = hermes_enable_port(hw, port);
+	}
+	if (err) {
+		printk(KERN_ERR "%s: Unable to enable port %d in orinco_reconfigure()\n", dev->name, port);
+		return err;
+	}
 
-	priv->hw_unavailable++;
-	priv->last_linkstatus = 0xffff; /* firmware will have to reassociate */
-	priv->connected = 0;
+	 return 0;
+}
 
-	orinoco_unlock(priv, &flags);
+/* This must be called from user context, without locks held - use schedule_work() */
+static void orinoco_reset(struct net_device *dev)  {
+	struct orinoco_private *priv = dev->priv;
+	int port, err;
+	unsigned long flags;
 
-	if (priv->hard_reset)
+	err = orinoco_lock(priv, &flags);
+	
+	priv->hw_unavailable = 1;
+	if(!err)
+		orinoco_unlock(priv, &flags);
+	
+	if ((priv->hard_reset) && ((!priv->ap_mode) || (priv->ap_mode & ORINOCO_AP_LEAVE))) {
+		priv->txfids=0;
+		priv->reset_active=1;
 		err = (*priv->hard_reset)(priv);
-	if (err) {
-		printk(KERN_ERR "%s: orinoco_reset: Error %d performing hard reset\n",
-		       dev->name, err);
-		/* FIXME: shutdown of some sort */
-		return;
+		priv->ap_mode&=~ORINOCO_AP_LEAVE;
+		mdelay(100);
+		priv->reset_active=0;
+		if(!err) {
+			err = orinoco_init(dev);
+			if(err) {
+				printk(KERN_ERR "%s: orinoco_reset: Error %d performing reinit after hard reset\n",
+					   dev->name, err);
+				dev->type=ARPHRD_ETHER;
+				return;
+			}
+		} /* !err */
+		else {
+			printk(KERN_ERR "%s: orinoco_reset: Error %d performing hard reset\n",
+				   dev->name, err);
+			dev->type=ARPHRD_ETHER;
+			/* FIXME: shutdown of some sort */
+			return;
+		}
 	}
-
-	err = orinoco_reinit_firmware(dev);
-	if (err) {
-		printk(KERN_ERR "%s: orinoco_reset: Error %d re-initializing firmware\n",
-		       dev->name, err);
+	else { /* soft reset */
+		err = orinoco_reinit_firmware(dev);
+		if (err) {
+			printk(KERN_ERR "%s: orinoco_reset: Error %d re-initializing firmware\n",
+				   dev->name, err);
+			dev->type=ARPHRD_ETHER;
+			return;
+		}
+	}
+	
+	if (dev->type != ARPHRD_ETHER) { /* monitoring */
+		err = orinoco_hw_monitor(dev);
+		if (err) {
+			printk(KERN_ERR "%s: orinoco_reset: Error %d re-initializing monitoring\n",
+				   dev->name, err);
+			dev->type=ARPHRD_ETHER;
+		}
 		return;
 	}
+	
+	spin_lock_irqsave(&priv->lock, flags);
 
-	spin_lock_irq(&priv->lock); /* This has to be called from user context */
+	priv->hw_unavailable = 0;
+	orinoco_hw_reconfigure(priv, 0);
+	
+	dev->trans_start = jiffies;
+	
+	for(port=0;port<WDS_PORTS;port++) {
+		if(priv->wdslink[port].dev.name[0]) {
+			priv->wdslink[port].dev.trans_start=jiffies;
+		}
+	} /* foreach WDSlink */
+		
+	orinoco_unlock(priv, &flags);
 
-	priv->hw_unavailable--;
+	return;
+}
 
-	/* priv->open or priv->hw_unavailable might have changed while
-	 * we dropped the lock */
-	if (priv->open && (! priv->hw_unavailable)) {
-		err = __orinoco_up(dev);
-		if (err) {
-			printk(KERN_ERR "%s: orinoco_reset: Error %d reenabling card\n",
-			       dev->name, err);
-		} else
-			dev->trans_start = jiffies;
-	}
+/* xyzzy */
+static int orinoco_reconfigure(struct net_device *dev, int disable_monitor) {
+	struct orinoco_private *priv = dev->priv;
+	unsigned long flags;
+	int err = 0;
+	
+	err=orinoco_lock(priv, &flags);
+	if(err)
+		return err;
 
-	spin_unlock_irq(&priv->lock);
+	if(dev->type != ARPHRD_ETHER) {
+		/* monitoring */
+		
+		if(disable_monitor) {
+			/* disable monitoring */
+			
+			priv->hw_unavailable=1;
+
+			err = orinoco_reinit_firmware(dev);
+			if (err) {
+				printk(KERN_ERR "%s: orinoco_reconfigure: Error %d re-initializing firmware\n", dev->name, err);
+				goto out;
+			}
+
+			priv->hw_unavailable=0;
+			
+			err = orinoco_hw_reconfigure(priv, 0);
+			if (err) {
+				printk(KERN_ERR "%s: orinoco_reconfigure: Error %d in hw_reconfig\n", dev->name, err);
+				goto out;
+			}
+		
+			dev->type=ARPHRD_ETHER;
+			
+			if(priv->open)
+				hermes_set_irqmask(&(priv->hw), ORINOCO_INTEN);
+			
+		} /* disable monitor */
+		
+		else {
+			/* reconfigure / enable */
+			err = orinoco_hw_monitor(dev);
+			if (err) {
+				printk(KERN_ERR "%s: orinoco_reconfigure: Error %d in hw_monitor\n", dev->name, err);
+			}
+		} /* (keep) enable(d) */
+	} /* monitor */
+	else
+		err = orinoco_hw_reconfigure(priv, 1);
+	
+	out:
+	orinoco_unlock(priv, &flags);
+	return err;
 
-	return;
 }
 
 /********************************************************************/
@@ -1058,18 +1304,10 @@
 	}
 }
 
-/* Does the frame have a SNAP header indicating it should be
- * de-encapsulated to Ethernet-II? */
 static inline int
-is_ethersnap(struct header_struct *hdr)
+is_snap(struct header_struct *hdr)
 {
-	/* We de-encapsulate all packets which, a) have SNAP headers
-	 * (i.e. SSAP=DSAP=0xaa and CTRL=0x3 in the 802.2 LLC header
-	 * and where b) the OUI of the SNAP header is 00:00:00 or
-	 * 00:00:f8 - we need both because different APs appear to use
-	 * different OUIs for some reason */
-	return (memcmp(&hdr->dsap, &encaps_hdr, 5) == 0)
-		&& ( (hdr->oui[2] == 0x00) || (hdr->oui[2] == 0xf8) );
+	return (hdr->dsap == 0xAA) && (hdr->ssap == 0xAA) && (hdr->ctrl == 0x3);
 }
 
 static void
@@ -1096,7 +1334,7 @@
 static int __orinoco_hw_set_bitrate(struct orinoco_private *priv)
 {
 	hermes_t *hw = &priv->hw;
-	int err = 0;
+	int err = 0, port;
 
 	if (priv->bitratemode >= BITRATE_TABLE_SIZE) {
 		printk(KERN_ERR "%s: BUG: Invalid bitrate mode %d\n",
@@ -1106,15 +1344,53 @@
 
 	switch (priv->firmware_type) {
 	case FIRMWARE_TYPE_AGERE:
-		err = hermes_write_wordrec(hw, USER_BAP,
-					   HERMES_RID_CNFTXRATECONTROL,
-					   bitrate_table[priv->bitratemode].agere_txratectrl);
+		if(!priv->ap_mode) {
+			err = hermes_write_wordrec(hw, USER_BAP,
+						   HERMES_RID_CNFTXRATECONTROL,
+						   bitrate_table[priv->bitratemode].agere_txratectrl);
+		} /* STA */
+		else {
+			/* port 0 */
+			err = hermes_write_wordrec(hw, USER_BAP,
+						   HERMES_RID_CNFTXRATECONTROL0,
+						   bitrate_table[priv->bitratemode].agere_txratectrl);
+			if(err)
+				break;
+			
+			/* WDS ports (1 ...) */
+			for(port=0;port < WDS_PORTS; port++) {
+				err = hermes_write_wordrec(hw, USER_BAP,
+						   HERMES_RID_CNFTXRATECONTROL1+port,
+						   bitrate_table[priv->wdslink[port].bitratemode].agere_txratectrl);
+				if(err)
+					break;
+			} /* foreach WDS port */
+		} /* BSS */
 		break;
 	case FIRMWARE_TYPE_INTERSIL:
 	case FIRMWARE_TYPE_SYMBOL:
-		err = hermes_write_wordrec(hw, USER_BAP,
-					   HERMES_RID_CNFTXRATECONTROL,
-					   bitrate_table[priv->bitratemode].intersil_txratectrl);
+		if(!priv->ap_mode) {
+			err = hermes_write_wordrec(hw, USER_BAP,
+						   HERMES_RID_CNFTXRATECONTROL,
+						   bitrate_table[priv->bitratemode].intersil_txratectrl);
+		} /* STA */
+		else {
+			/* port 0 */
+			err = hermes_write_wordrec(hw, USER_BAP,
+						   HERMES_RID_CNFTXRATECONTROL0,
+						   bitrate_table[priv->bitratemode].intersil_txratectrl);
+			if(err)
+				break;
+			
+			/* WDS ports (1 ...) */
+			for(port=0;port < WDS_PORTS; port++) {
+				err = hermes_write_wordrec(hw, USER_BAP,
+						   HERMES_RID_CNFTXRATECONTROL1+port,
+						   bitrate_table[priv->wdslink[port].bitratemode].intersil_txratectrl);
+				if(err)
+					break;
+			} /* foreach WDS port */
+		} /* BSS */
 		break;
 	default:
 		BUG();
@@ -1227,13 +1503,18 @@
 	return 0;
 }
 
-static int orinoco_hw_get_bssid(struct orinoco_private *priv,
-				char buf[ETH_ALEN])
+static int orinoco_hw_get_bssid(struct orinoco_private *priv, char buf[ETH_ALEN])
 {
 	hermes_t *hw = &priv->hw;
 	int err = 0;
 	unsigned long flags;
+	unsigned char zeromac[ETH_ALEN]={0,0,0,0,0,0};
 
+	if(priv->ap_mode) {
+		memcpy(buf,zeromac,ETH_ALEN);
+		return 0;
+	}
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
@@ -1247,7 +1528,7 @@
 }
 
 static int orinoco_hw_get_essid(struct orinoco_private *priv, int *active,
-				char buf[IW_ESSID_MAX_SIZE+1])
+			      char buf[IW_ESSID_MAX_SIZE+1])
 {
 	hermes_t *hw = &priv->hw;
 	int err = 0;
@@ -1260,7 +1541,7 @@
 	if (err)
 		return err;
 
-	if (strlen(priv->desired_essid) > 0) {
+	if ((strlen(priv->desired_essid) > 0) || (priv->ap_mode)) {
 		/* We read the desired SSID from the hardware rather
 		   than from priv->desired_essid, just in case the
 		   firmware is allowed to change it on us. I'm not
@@ -1272,14 +1553,16 @@
 
 		*active = 1;
 
-		rid = (priv->port_type == 3) ? HERMES_RID_CNFOWNSSID :
+		rid = ((priv->port_type == 3) || (priv->ap_mode)) ? HERMES_RID_CNFOWNSSID :
 			HERMES_RID_CNFDESIREDSSID;
 		
 		err = hermes_read_ltv(hw, USER_BAP, rid, sizeof(essidbuf),
 				      NULL, &essidbuf);
+
 		if (err)
 			goto fail_unlock;
 	} else {
+
 		*active = 0;
 
 		err = hermes_read_ltv(hw, USER_BAP, HERMES_RID_CURRENTSSID,
@@ -1324,8 +1607,7 @@
 	}
 
 	if ( (channel < 1) || (channel > NUM_CHANNELS) ) {
-		printk(KERN_WARNING "%s: Channel out of range (%d)!\n",
-		       priv->ndev->name, channel);
+		printk(KERN_WARNING "%s: Channel out of range (%d)!\n", priv->ndev->name, channel);
 		err = -EBUSY;
 		goto out;
 
@@ -1340,8 +1622,8 @@
 	return err ? err : freq;
 }
 
-static int orinoco_hw_get_bitratelist(struct orinoco_private *priv,
-				      int *numrates, s32 *rates, int max)
+static int orinoco_hw_get_bitratelist(struct orinoco_private *priv, int *numrates,
+				    s32 *rates, int max)
 {
 	hermes_t *hw = &priv->hw;
 	struct hermes_idstring list;
@@ -1374,6 +1656,9 @@
 }
 
 #if 0
+#ifndef ORINOCO_DEBUG
+static inline void show_rx_frame(struct orinoco_rxframe_hdr *frame) {}
+#else
 static void show_rx_frame(struct orinoco_rxframe_hdr *frame)
 {
 	printk(KERN_DEBUG "RX descriptor:\n");
@@ -1386,10 +1671,8 @@
 	printk(KERN_DEBUG "  reserved    = 0x%08x\n", frame->desc.reserved);
 
 	printk(KERN_DEBUG "IEEE 802.11 header:\n");
-	printk(KERN_DEBUG "  frame_ctl   = 0x%04x\n",
-	       frame->p80211.frame_ctl);
-	printk(KERN_DEBUG "  duration_id = 0x%04x\n",
-	       frame->p80211.duration_id);
+	printk(KERN_DEBUG "  frame_ctl   = 0x%04x\n", frame->p80211.frame_ctl);
+	printk(KERN_DEBUG "  duration_id = 0x%04x\n", frame->p80211.duration_id);
 	printk(KERN_DEBUG "  addr1       = %02x:%02x:%02x:%02x:%02x:%02x\n",
 	       frame->p80211.addr1[0], frame->p80211.addr1[1],
 	       frame->p80211.addr1[2], frame->p80211.addr1[3],
@@ -1402,14 +1685,12 @@
 	       frame->p80211.addr3[0], frame->p80211.addr3[1],
 	       frame->p80211.addr3[2], frame->p80211.addr3[3],
 	       frame->p80211.addr3[4], frame->p80211.addr3[5]);
-	printk(KERN_DEBUG "  seq_ctl     = 0x%04x\n",
-	       frame->p80211.seq_ctl);
+	printk(KERN_DEBUG "  seq_ctl     = 0x%04x\n", frame->p80211.seq_ctl);
 	printk(KERN_DEBUG "  addr4       = %02x:%02x:%02x:%02x:%02x:%02x\n",
 	       frame->p80211.addr4[0], frame->p80211.addr4[1],
 	       frame->p80211.addr4[2], frame->p80211.addr4[3],
 	       frame->p80211.addr4[4], frame->p80211.addr4[5]);
-	printk(KERN_DEBUG "  data_len    = 0x%04x\n",
-	       frame->p80211.data_len);
+	printk(KERN_DEBUG "  data_len    = 0x%04x\n", frame->p80211.data_len);
 
 	printk(KERN_DEBUG "IEEE 802.3 header:\n");
 	printk(KERN_DEBUG "  dest        = %02x:%02x:%02x:%02x:%02x:%02x\n",
@@ -1430,13 +1711,13 @@
 	       frame->p8022.oui[0], frame->p8022.oui[1], frame->p8022.oui[2]);
 	printk(KERN_DEBUG "  ethertype  = 0x%04x\n", frame->ethertype);
 }
-#endif /* 0 */
+#endif
+#endif
 
 /*
  * Interrupt handler
  */
-irqreturn_t orinoco_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
+void orinoco_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
 	struct net_device *dev = (struct net_device *)dev_id;
 	struct orinoco_private *priv = dev->priv;
 	hermes_t *hw = &priv->hw;
@@ -1450,17 +1731,12 @@
 	unsigned long flags;
 
 	if (orinoco_lock(priv, &flags) != 0) {
-		/* If hw is unavailable - we don't know if the irq was
-		 * for us or not */
-		return IRQ_HANDLED;
+		/* If hw is unavailable */
+		return;
 	}
 
 	evstat = hermes_read_regn(hw, EVSTAT);
 	events = evstat & hw->inten;
-	if (! events) {
-		orinoco_unlock(priv, &flags);
-		return IRQ_NONE;
-	}
 	
 	if (jiffies != last_irq_jiffy)
 		loops_this_jiffy = 0;
@@ -1468,11 +1744,11 @@
 
 	while (events && count--) {
 		if (++loops_this_jiffy > MAX_IRQLOOPS_PER_JIFFY) {
-			printk(KERN_WARNING "%s: IRQ handler is looping too "
-			       "much! Resetting.\n", dev->name);
-			/* Disable interrupts for now */
+			printk(KERN_CRIT "%s: IRQ handler is looping too \
+much! Shutting down.\n",
+			       dev->name);
+			/* Perform an emergency shutdown */
 			hermes_set_irqmask(hw, 0);
-			schedule_work(&priv->reset_work);
 			break;
 		}
 
@@ -1506,24 +1782,19 @@
 	};
 
 	orinoco_unlock(priv, &flags);
-	return IRQ_HANDLED;
 }
 
-static void __orinoco_ev_tick(struct net_device *dev, hermes_t *hw)
-{
+static void __orinoco_ev_tick(struct net_device *dev, hermes_t *hw) {
 	printk(KERN_DEBUG "%s: TICK\n", dev->name);
 }
 
-static void __orinoco_ev_wterr(struct net_device *dev, hermes_t *hw)
-{
+static void __orinoco_ev_wterr(struct net_device *dev, hermes_t *hw) {
 	/* This seems to happen a fair bit under load, but ignoring it
 	   seems to work fine...*/
-	printk(KERN_DEBUG "%s: MAC controller error (WTERR). Ignoring.\n",
-	       dev->name);
+	printk(KERN_DEBUG "%s: MAC controller error (WTERR). Ignoring.\n", dev->name);
 }
 
-static void __orinoco_ev_infdrop(struct net_device *dev, hermes_t *hw)
-{
+static void __orinoco_ev_infdrop(struct net_device *dev, hermes_t *hw) {
 	printk(KERN_WARNING "%s: Information frame lost.\n", dev->name);
 }
 
@@ -1531,9 +1802,6 @@
 {
 	char * s;
 
-	if (suppress_linkstatus)
-		return;
-
 	switch (status) {
 	case HERMES_LINKSTATUS_NOT_CONNECTED:
 		s = "Not Connected";
@@ -1564,8 +1832,18 @@
 	       dev->name, s, status);
 }
 
-static void __orinoco_ev_info(struct net_device *dev, hermes_t *hw)
-{
+struct assoc_status {
+        u16 status;
+        u8 sta_addr[ETH_ALEN];
+        u8 old_ap_addr[ETH_ALEN];
+        u16 reason, reserved;
+} __attribute__ ((packed));
+struct auth_status {
+	u16 status; /* not sure */
+	u8 sta_addr[ETH_ALEN];
+	u16 dunno;
+} __attribute__ ((packed));
+static void __orinoco_ev_info(struct net_device *dev, hermes_t *hw) {
 	struct orinoco_private *priv = dev->priv;
 	u16 infofid;
 	struct {
@@ -1627,6 +1905,73 @@
 #endif /* WIRELESS_EXT > 11 */
 	}
 	break;
+	case HERMES_INQ_ASSOCSTATUS: {
+		struct assoc_status assoc_status;
+		
+		if (len > sizeof(assoc_status)) {
+			printk(KERN_WARNING "%s: assoc status frame too long\n", dev->name);
+			len = sizeof(assoc_status);
+		}
+		
+		/* Read directly the data (no seek) */
+		hermes_read_words(hw, HERMES_DATA1, (void *) &assoc_status, len>>1);
+		
+		switch (le16_to_cpu(assoc_status.status)) {
+			case 1:
+				printk(KERN_INFO"%s: %02X:%02X:%02X:%02X:%02X:%02X associated\n",
+						dev->name, assoc_status.sta_addr[0], assoc_status.sta_addr[1], assoc_status.sta_addr[2], 
+						assoc_status.sta_addr[3], assoc_status.sta_addr[4], assoc_status.sta_addr[5]);
+			break;
+			case 2:
+				printk(KERN_INFO"%s: %02X:%02X:%02X:%02X:%02X:%02X reassociated from %02X:%02X:%02X:%02X:%02X:%02X\n",
+						dev->name, assoc_status.sta_addr[0], assoc_status.sta_addr[1], assoc_status.sta_addr[2], 
+						assoc_status.sta_addr[3], assoc_status.sta_addr[4], assoc_status.sta_addr[5],
+						assoc_status.old_ap_addr[0], assoc_status.old_ap_addr[1], assoc_status.old_ap_addr[2], 
+						assoc_status.old_ap_addr[3], assoc_status.old_ap_addr[4], assoc_status.old_ap_addr[5]);
+			break;
+			case 3:
+				printk(KERN_INFO"%s: %02X:%02X:%02X:%02X:%02X:%02X disassociated - reason: %04X\n",
+						dev->name, assoc_status.sta_addr[0], assoc_status.sta_addr[1], assoc_status.sta_addr[2], 
+						assoc_status.sta_addr[3], assoc_status.sta_addr[4], assoc_status.sta_addr[5], assoc_status.reason);
+			break;
+			case 4:
+				printk(KERN_INFO"%s: %02X:%02X:%02X:%02X:%02X:%02X association failed - reason: %04X\n",
+						dev->name, assoc_status.sta_addr[0], assoc_status.sta_addr[1], assoc_status.sta_addr[2], 
+						assoc_status.sta_addr[3], assoc_status.sta_addr[4], assoc_status.sta_addr[5], assoc_status.reason);
+			break;
+			case 5:
+				printk(KERN_INFO"%s: %02X:%02X:%02X:%02X:%02X:%02X authentication failed - reason: %04X\n",
+						dev->name, assoc_status.sta_addr[0], assoc_status.sta_addr[1], assoc_status.sta_addr[2], 
+						assoc_status.sta_addr[3], assoc_status.sta_addr[4], assoc_status.sta_addr[5], assoc_status.reason);
+			break;
+			default:
+			printk(KERN_INFO
+			"%s: unknown status: %04X len %d sta %02X:%02X:%02X:%02X:%02X:%02X old_ap %02X:%02X:%02X:%02X:%02X:%02X reason: %04X reserved: %04X\n",
+						dev->name, assoc_status.status, le16_to_cpu(info.len), 
+						assoc_status.sta_addr[0], assoc_status.sta_addr[1], assoc_status.sta_addr[2], 
+						assoc_status.sta_addr[3], assoc_status.sta_addr[4], assoc_status.sta_addr[5],
+						assoc_status.old_ap_addr[0], assoc_status.old_ap_addr[1], assoc_status.old_ap_addr[2], 
+						assoc_status.old_ap_addr[3], assoc_status.old_ap_addr[4], assoc_status.old_ap_addr[5],
+						assoc_status.reason, assoc_status.reserved);
+			break;
+		}
+	}
+	break;
+	case HERMES_INQ_AUTHSTATUS: {
+		struct auth_status auth_status;
+			
+		if (len > sizeof(auth_status)) {
+			printk(KERN_WARNING "%s: auth status frame too long\n", dev->name);
+			len = sizeof(auth_status);
+		}
+		
+		/* Read directly the data (no seek) */
+		hermes_read_words(hw, HERMES_DATA1, (void *) &auth_status, len>>1);	
+		printk(KERN_INFO"%s: auth status %04X sta %02X:%02X:%02X:%02X:%02X:%02X dunno: %04X\n",
+					dev->name, auth_status.status, auth_status.sta_addr[0], auth_status.sta_addr[1], auth_status.sta_addr[2], 
+					auth_status.sta_addr[3], auth_status.sta_addr[4], auth_status.sta_addr[5], auth_status.dunno);
+	}
+	break;
 	case HERMES_INQ_LINKSTATUS: {
 		struct hermes_linkstatus linkstatus;
 		u16 newstatus;
@@ -1657,16 +2002,26 @@
 		priv->last_linkstatus = newstatus;
 	}
 	break;
-	default:
-		printk(KERN_DEBUG "%s: Unknown information frame received (type %04x).\n",
-		      dev->name, type);
-		/* We don't actually do anything about it */
+	default: {
+		u8 data[256];
+		int count;
+		
+		printk(KERN_DEBUG "%s: Unknown information frame received (type %04x len %d).\n",
+		      priv->ndev->name, le16_to_cpu(info.type),len);
+		/* Read directly the data (no seek) */
+		if(len>sizeof(data))
+			len=sizeof(data);
+		hermes_read_words(hw, HERMES_DATA1, (void *) data, len>>1);
+		printk(KERN_DEBUG);
+		for(count=0;count<len;count+=2)
+			printk("%02X%02X ",data[count],data[count+1]);
+		printk("\n");
+		}
 		break;
 	}
 }
 
-static void __orinoco_ev_rx(struct net_device *dev, hermes_t *hw)
-{
+static void __orinoco_ev_rx(struct net_device *dev, hermes_t *hw) {
 	struct orinoco_private *priv = dev->priv;
 	struct net_device_stats *stats = &priv->stats;
 	struct iw_statistics *wstats = &priv->wstats;
@@ -1678,6 +2033,8 @@
 	struct header_struct hdr;
 	struct ethhdr *eh;
 	int err;
+	int port;
+	struct ieee802_11_hdr hdr80211;
 
 	rxfid = hermes_read_regn(hw, RXFID);
 
@@ -1692,8 +2049,25 @@
 
 	status = le16_to_cpu(desc.status);
 	
+	/* WDS */
+	port=(status&HERMES_RXSTAT_MACPORT)>>8;
+	if((port >= 1) && (port <= WDS_PORTS)) {
+		if(priv->wdslink[port-1].dev.name[0]) { /* or netif_running? */
+			dev=&(priv->wdslink[port-1].dev);
+			stats=&(priv->wdslink[port-1].stats);
+			wstats=&(priv->wdslink[port-1].wstats);
+			wstats->qual.noise=desc.silence;
+			wstats->qual.level=desc.signal;
+			wstats->qual.updated++;
+		}
+		else /* shouldn't happen... */
+			return;
+	}
+	
 	if (status & HERMES_RXSTAT_ERR) {
 		if (status & HERMES_RXSTAT_UNDECRYPTABLE) {
+			if (dev->type != ARPHRD_ETHER)
+				goto sniffing;
 			wstats->discard.code++;
 			DEBUG(1, "%s: Undecryptable frame on Rx. Frame dropped.\n",
 			       dev->name);
@@ -1704,7 +2078,7 @@
 		stats->rx_errors++;
 		goto drop;
 	}
-
+sniffing:
 	/* For now we ignore the 802.11 header completely, assuming
            that the card's firmware has handled anything vital */
 
@@ -1735,6 +2109,28 @@
 		goto drop;
 	}
 
+	if(port==7) {
+		/* monitoring port */
+
+		if ((dev->type != ARPHRD_IEEE80211) && (dev->type != ARPHRD_IEEE80211_PRISM)){
+			printk(KERN_ERR"%s: WAAH! wrong ARPHRD_ while monitoring?!?!\n",dev->name);
+			goto drop;
+		}
+		
+		if(!(status&HERMES_RXSTAT_BADCRC)) {
+			if (hermes_bap_pread(hw, IRQ_BAP, &hdr80211, sizeof(hdr80211), rxfid, HERMES_802_11_OFFSET))
+				stats->rx_errors++;
+			else
+				orinoco_int_rxmonitor( dev, rxfid, length, &desc, &hdr80211);
+		} /* FCSErr */
+		
+		return;
+	}
+	else if (dev->type != ARPHRD_ETHER) {
+		printk(KERN_ERR"%s: WAAH! wrong ARPHRD_ while not monitoring?!?!\n",dev->name);
+		goto drop;
+	}
+	
 	/* We need space for the packet data itself, plus an ethernet
 	   header, plus 2 bytes so we can align the IP header on a
 	   32bit boundary, plus 1 byte so we can read in odd length
@@ -1756,13 +2152,14 @@
 	 * So, check ourselves */
 	if(((status & HERMES_RXSTAT_MSGTYPE) == HERMES_RXSTAT_1042) ||
 	   ((status & HERMES_RXSTAT_MSGTYPE) == HERMES_RXSTAT_TUNNEL) ||
-	   is_ethersnap(&hdr)) {
+	   is_snap(&hdr)) {
 		/* These indicate a SNAP within 802.2 LLC within
 		   802.11 frame which we'll need to de-encapsulate to
 		   the original EthernetII frame. */
 
 		if (length < ENCAPS_OVERHEAD) { /* No room for full LLC+SNAP */
 			stats->rx_length_errors++;
+			stats->rx_dropped++;
 			goto drop;
 		}
 
@@ -1817,58 +2214,228 @@
 	return;
 }
 
-static void __orinoco_ev_txexc(struct net_device *dev, hermes_t *hw)
-{
+void orinoco_int_rxmonitor( struct net_device *dev, uint16_t rxfid, int len,
+                            struct hermes_rx_descriptor *rxdesc, struct ieee802_11_hdr *hdr) {
 	struct orinoco_private *priv = dev->priv;
+	hermes_t			*hw = &(priv->hw);
+	uint32_t				hdrlen = 0;
+	uint32_t				datalen = 0;
+	uint32_t				skblen = 0;
+	p80211msg_lnxind_wlansniffrm_t	*msg;
 	struct net_device_stats *stats = &priv->stats;
-	u16 fid = hermes_read_regn(hw, TXCOMPLFID);
-	struct hermes_tx_descriptor desc;
-	int err = 0;
 
-	if (fid == DUMMY_FID)
-		return; /* Nothing's really happened */
 
-	err = hermes_bap_pread(hw, IRQ_BAP, &desc, sizeof(desc), fid, 0);
-	if (err) {
-		printk(KERN_WARNING "%s: Unable to read descriptor on Tx error "
-		       "(FID=%04X error %d)\n",
-		       dev->name, fid, err);
-	} else {
-		DEBUG(1, "%s: Tx error, status %d\n",
-		      dev->name, le16_to_cpu(desc.status));
+	uint8_t				*datap;
+	uint16_t				fc;
+	struct sk_buff			*skb;
+
+	/* Don't forget the status, time, and data_len fields are in host order */
+	/* Figure out how big the frame is */
+	fc = le16_to_cpu(hdr->frame_ctl);
+	switch ( WLAN_GET_FC_FTYPE(fc) )
+	{
+	case WLAN_FTYPE_DATA:
+		if ( WLAN_GET_FC_TODS(fc) && WLAN_GET_FC_FROMDS(fc) ) {
+			hdrlen = WLAN_HDR_A4_LEN;
+		} else {
+			hdrlen = WLAN_HDR_A3_LEN;
+		}
+		datalen = len;
+		break;
+	case WLAN_FTYPE_MGMT:
+		hdrlen = WLAN_HDR_A3_LEN;
+		datalen = len;
+		break;
+	case WLAN_FTYPE_CTL:
+		switch ( WLAN_GET_FC_FSTYPE(fc) )
+		{
+		case WLAN_FSTYPE_PSPOLL:
+		case WLAN_FSTYPE_RTS:
+		case WLAN_FSTYPE_CFEND:
+		case WLAN_FSTYPE_CFENDCFACK:
+			hdrlen = 16;
+			break;
+		case WLAN_FSTYPE_CTS:
+		case WLAN_FSTYPE_ACK:
+			hdrlen = 10;
+			break;
+		}
+		datalen = 0;
+		break;
+	default:
+		printk("unknown frm: fc=0x%04x\n", fc);
+		return;
 	}
-	
-	stats->tx_errors++;
 
-	hermes_write_regn(hw, TXCOMPLFID, DUMMY_FID);
-}
+	/* Allocate an ind message+framesize skb */
+	skblen = sizeof(p80211msg_lnxind_wlansniffrm_t) + hdrlen + datalen;
+	
+	/* sanity check the length */
+	if ( skblen > (sizeof(p80211msg_lnxind_wlansniffrm_t) + 
+		WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
+		printk("overlen frm: len=%d\n", 
+			skblen - sizeof(p80211msg_lnxind_wlansniffrm_t));
+	}
+			
+	if ( (skb = dev_alloc_skb(skblen)) == NULL ) {
+		printk("alloc_skb failed trying to allocate %d bytes\n", skblen);
+		return;
+	}
 
-static void __orinoco_ev_tx(struct net_device *dev, hermes_t *hw)
-{
+	/* only prepend the prism header if in the right mode */
+	if (dev->type != ARPHRD_IEEE80211_PRISM) {
+	  skb_put(skb, skblen - sizeof(p80211msg_lnxind_wlansniffrm_t));
+	  datap = skb->data;
+	}
+	else {
+	  skb_put(skb, skblen);
+	  datap = skb->data + sizeof(p80211msg_lnxind_wlansniffrm_t);
+	  msg = (p80211msg_lnxind_wlansniffrm_t*)skb->data;
+	  
+	  /* Initialize the message members */
+	  msg->msgcode = DIDmsg_lnxind_wlansniffrm;
+	  msg->msglen = sizeof(p80211msg_lnxind_wlansniffrm_t);
+	  strcpy(msg->devname, dev->name);
+	  
+	  msg->hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
+	  msg->hosttime.status = 0;
+	  msg->hosttime.len = 4;
+	  msg->hosttime.data = jiffies;
+	  
+	  msg->mactime.did = DIDmsg_lnxind_wlansniffrm_mactime;
+	  msg->mactime.status = 0;
+	  msg->mactime.len = 4;
+	  msg->mactime.data = rxdesc->time;
+	  
+	  msg->channel.did = DIDmsg_lnxind_wlansniffrm_channel;
+	  msg->channel.status = P80211ENUM_msgitem_status_no_value;
+	  msg->channel.len = 4;
+	  msg->channel.data = 0;
+
+	  msg->rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
+	  msg->rssi.status = P80211ENUM_msgitem_status_no_value;
+	  msg->rssi.len = 4;
+	  msg->rssi.data = 0;
+	  
+	  msg->sq.did = DIDmsg_lnxind_wlansniffrm_sq;
+	  msg->sq.status = P80211ENUM_msgitem_status_no_value;
+	  msg->sq.len = 4;
+	  msg->sq.data = 0;
+	  
+	  msg->signal.did = DIDmsg_lnxind_wlansniffrm_signal;
+	  msg->signal.status = 0;
+	  msg->signal.len = 4;
+	  msg->signal.data = rxdesc->signal;
+	  
+	  msg->noise.did = DIDmsg_lnxind_wlansniffrm_noise;
+	  msg->noise.status = 0;
+	  msg->noise.len = 4;
+	  msg->noise.data = rxdesc->silence;
+
+	  msg->rate.did = DIDmsg_lnxind_wlansniffrm_rate;
+	  msg->rate.status = 0;
+	  msg->rate.len = 4;
+	  msg->rate.data = rxdesc->rate / 5; /* set to 802.11 units */
+  
+	  msg->istx.did = DIDmsg_lnxind_wlansniffrm_istx;
+	  msg->istx.status = 0;
+	  msg->istx.len = 4;
+	  msg->istx.data = P80211ENUM_truth_false;
+	  
+	  msg->frmlen.did = DIDmsg_lnxind_wlansniffrm_frmlen;
+	  msg->frmlen.status = 0;
+	  msg->frmlen.len = 4;
+	  msg->frmlen.data = hdrlen + datalen;
+	}	  
+
+	/* Copy the 802.11 header to the skb (ctl frames may be less than a full header) */
+	memcpy( datap, &(hdr->frame_ctl), hdrlen);
+
+	/* If any, copy the data from the card to the skb */
+	if ( datalen > 0 ) {
+		hermes_bap_pread(hw, IRQ_BAP, datap + hdrlen, (datalen+1)&~1,
+				       rxfid, HERMES_802_2_OFFSET);
+
+		/* check for unencrypted stuff if WEP bit set. */
+		if (*(datap+1) & 0x40) // wep set
+		  if ((*(datap+hdrlen) == 0xaa) && (*(datap+hdrlen+1) == 0xaa))
+		    *(datap+1) &= 0xbf; // clear wep; it's the 802.2 header!
+	}
+
+       /* pass it up via the PF_PACKET interface */
+	skb->dev = dev;
+	skb->dev->last_rx = jiffies;
+
+	skb->mac.raw = skb->data ;
+	skb->ip_summed = CHECKSUM_NONE;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_80211_RAW);  /* XXX ETH_P_802_2? */
+
+	stats->rx_packets++;
+	stats->rx_bytes += skb->len;
+
+	netif_rx(skb);
+
+	return;
+}
+
+static void __orinoco_ev_txexc(struct net_device *dev, hermes_t *hw) {
 	struct orinoco_private *priv = dev->priv;
 	struct net_device_stats *stats = &priv->stats;
+	u16 fid = hermes_read_regn(hw, TXCOMPLFID);
+	struct hermes_tx_descriptor desc;
+	int err = 0;
 
-	stats->tx_packets++;
+	if (fid == ORINOCO_DUMMY_FID)
+		return; /* Nothing's really happened */
+
+	err = hermes_bap_pread(hw, IRQ_BAP, &desc, sizeof(desc), fid, 0);
+	if (err) {
+		printk(KERN_WARNING "%s: Unable to read descriptor on Tx error "
+		       "(FID=%04X error %d)\n",
+		       dev->name, fid, err);
+	} else {
+		DEBUG(1, "%s: Tx error, status %d\n",
+		      dev->name, le16_to_cpu(desc.status));
+	}
+	
+	stats->tx_errors++;
 
-	hermes_write_regn(hw, TXCOMPLFID, DUMMY_FID);
+	hermes_write_regn(hw, TXCOMPLFID, ORINOCO_DUMMY_FID);
 }
 
-static void __orinoco_ev_alloc(struct net_device *dev, hermes_t *hw)
-{
+static void __orinoco_ev_tx(struct net_device *dev, hermes_t *hw) {
 	struct orinoco_private *priv = dev->priv;
+	struct net_device_stats *stats = &priv->stats;
 
-	u16 fid = hermes_read_regn(hw, ALLOCFID);
+	stats->tx_packets++;
+
+	hermes_write_regn(hw, TXCOMPLFID, ORINOCO_DUMMY_FID);
+}
 
-	if (fid != priv->txfid) {
-		if (fid != DUMMY_FID)
-			printk(KERN_WARNING "%s: Allocate event on unexpected fid (%04X)\n",
-			       dev->name, fid);
+static void __orinoco_ev_alloc(struct net_device *dev, hermes_t *hw) {
+	struct orinoco_private *priv = dev->priv;
+	u16 fid = hermes_read_regn(hw, ALLOCFID);
+	int port;
+	
+	if((fid == ORINOCO_DUMMY_FID) || (!fid))
+		return;
+	
+	if(orinoco_push_txfid(priv, fid)) {
+		/* shouldn't happen - what to do here? free() it? */
+		printk(KERN_ERR"orinoco.c: WAAH! Too many TxFids for %s!\n",priv->ndev->name);
 		return;
-	} else {
-		netif_wake_queue(dev);
 	}
+	else if(priv->txfids==1) {
+		netif_wake_queue(priv->ndev);
+		for(port=0;port<WDS_PORTS;port++) {
+			if(priv->wdslink[port].dev.name[0]) {
+				netif_wake_queue(&priv->wdslink[port].dev);
+			} /* wake the queue */
+		} /* foreach WDSlink */
+	} /* new TXfid */
 
-	hermes_write_regn(hw, ALLOCFID, DUMMY_FID);
+	hermes_write_regn(hw, ALLOCFID, ORINOCO_DUMMY_FID);
 }
 
 struct sta_id {
@@ -1896,15 +2463,66 @@
 	int err;
 	struct sta_id sta_id;
 	unsigned int firmver;
+	u16 len;
 	char tmp[SYMBOL_MAX_VER_LEN+1];
-
+	
 	/* Get the firmware version */
-	err = HERMES_READ_RECORD(hw, USER_BAP, HERMES_RID_STAID, &sta_id);
+	err = hermes_read_ltv(hw, USER_BAP, HERMES_RID_STAID, sizeof(struct sta_id),&len,&sta_id);
 	if (err) {
 		printk(KERN_WARNING "%s: Error %d reading firmware info. Wildly guessing capabilities...\n",
 		       dev->name, err);
 		memset(&sta_id, 0, sizeof(sta_id));
 	}
+	
+	if(!len) {
+		/* BSS creation fw? */
+		struct hermes_idstring essidbuf;
+		char *p = (char *)(&essidbuf.val);
+		
+		err = hermes_read_ltv(hw, USER_BAP, HERMES_RID_CNFOWNSSID,
+						  sizeof(essidbuf), NULL, &essidbuf);
+		
+		if(!err) {
+			len = le16_to_cpu(essidbuf.len);
+
+			memset(priv->desired_essid, 0, IW_ESSID_MAX_SIZE+1);
+			memcpy(priv->desired_essid, p, len);
+			priv->desired_essid[len] = '\0';
+		
+			if(!len)
+				strcpy(priv->desired_essid,"HermesAP");
+			
+			priv->ap_mode|=ORINOCO_AP_ENABLED;
+			dev->type=ARPHRD_ETHER;
+			printk(KERN_DEBUG"%s: switching to AP mode\n",dev->name);
+		
+			/* most configuration RIDs are empty now, but
+			   we're already configured from card insert
+				 since firmware upload was after this insert ;)
+				 so we _should_ be able to continue with the
+				 previously read values	*/
+		
+			return;
+		}
+		else
+			printk(KERN_WARNING"%s: firmware has gone mad...\n",dev->name);
+	}
+	else {
+		int port;
+
+		if(priv->ap_mode)
+			printk(KERN_INFO"%s: Leaving AP mode - removing leftover WDSlinks\n",dev->name);
+		
+		/* unregister WDS ndevs */
+		for(port=0;port<WDS_PORTS;port++) {
+			if(priv->wdslink[port].dev.name[0]) {
+				unregister_netdevice(&(priv->wdslink[port].dev));
+				priv->wdslink[port].dev.name[0]=0;
+			}
+		}
+		priv->ap_mode=0;
+	}
+	
 	le16_to_cpus(&sta_id.id);
 	le16_to_cpus(&sta_id.variant);
 	le16_to_cpus(&sta_id.major);
@@ -2038,11 +2656,17 @@
 
 	TRACE_ENTER(dev->name);
 
-	/* No need to lock, the hw_unavailable flag is already set in
+	if(dev != priv->ndev) {
+		memcpy(dev->dev_addr, priv->ndev->dev_addr, ETH_ALEN);
+		goto out;
+	}
+	
+	/* No need to lock, the resetting flag is already set in
 	 * alloc_orinocodev() */
 	priv->nicbuf_size = IEEE802_11_FRAME_LEN + ETH_HLEN;
 
 	/* Initialize the firmware */
+	priv->txfids=0;
 	err = hermes_init(hw);
 	if (err != 0) {
 		printk(KERN_ERR "%s: failed to initialize firmware (err = %d)\n",
@@ -2051,6 +2675,9 @@
 	}
 
 	determine_firmware(dev);
+	
+	if(priv->ap_mode)
+		goto finish;
 
 	if (priv->has_port3)
 		printk(KERN_DEBUG "%s: Ad-hoc demo mode supported\n", dev->name);
@@ -2078,7 +2705,7 @@
 	       dev->name, dev->dev_addr[0], dev->dev_addr[1],
 	       dev->dev_addr[2], dev->dev_addr[3], dev->dev_addr[4],
 	       dev->dev_addr[5]);
-
+	
 	/* Get the station name */
 	err = hermes_read_ltv(hw, USER_BAP, HERMES_RID_CNFOWNNAME,
 			      sizeof(nickbuf), &reclen, &nickbuf);
@@ -2162,42 +2789,39 @@
 		if (err)
 			goto out;
 	}
-		
-	/* Set up the default configuration */
-	priv->iw_mode = IW_MODE_INFRA;
+	
+	/* Set up the default configuration - TODO: only if 1st fw-boot */
+	if(priv->iw_mode != IW_MODE_ADHOC)
+		priv->iw_mode = IW_MODE_INFRA;
 	/* By default use IEEE/IBSS ad-hoc mode if we have it */
 	priv->prefer_port3 = priv->has_port3 && (! priv->has_ibss);
 	set_port_type(priv);
-	priv->channel = 10; /* default channel, more-or-less arbitrary */
+	if((priv->channel<1) || (priv->channel>12))
+		priv->channel = 10; /* default channel, more-or-less arbitrary */
 
+  finish:
+	
 	priv->promiscuous = 0;
 	priv->wep_on = 0;
 	priv->tx_key = 0;
 
-	err = hermes_allocate(hw, priv->nicbuf_size, &priv->txfid);
-	if (err == -EIO) {
-		/* Try workaround for old Symbol firmware bug */
-		printk(KERN_WARNING "%s: firmware ALLOC bug detected "
-		       "(old Symbol firmware?). Trying to work around... ",
-		       dev->name);
-		
-		priv->nicbuf_size = TX_NICBUF_SIZE_BUG;
-		err = hermes_allocate(hw, priv->nicbuf_size, &priv->txfid);
-		if (err)
-			printk("failed!\n");
-		else
-			printk("ok.\n");
-	}
+	priv->hw_unavailable = 0;
+	
+	if(dev->type != ARPHRD_ETHER)
+		goto out;
+
+	err=orinoco_alloc_txfids(priv, ORINOCO_TXFIDS);
 	if (err) {
 		printk("%s: Error %d allocating Tx buffer\n", dev->name, err);
 		goto out;
 	}
 
-	/* Make the hardware available, as long as it hasn't been
-	 * removed elsewhere (e.g. by PCMCIA hot unplug) */
-	spin_lock_irq(&priv->lock);
-	priv->hw_unavailable--;
-	spin_unlock_irq(&priv->lock);
+	if(priv->txfids<=0) {
+		printk(KERN_ERR"orinoco: WAAH! Couldn't alloc any TxFid for %s\n",dev->name);
+		goto out;
+	}
+	else if(priv->txfids<ORINOCO_TXFIDS)
+		printk(KERN_WARNING"orinoco: Could only alloc %d of %d TxFids\n",err,ORINOCO_TXFIDS);
 
 	printk(KERN_DEBUG "%s: ready\n", dev->name);
 
@@ -2210,8 +2834,19 @@
 orinoco_get_stats(struct net_device *dev)
 {
 	struct orinoco_private *priv = dev->priv;
+	struct net_device_stats *stats=&priv->stats;
+	
+	if(dev != priv->ndev) {
+		int port=orinoco_lookup_port(dev);
+		
+		if((port<1) || (port>WDS_PORTS)) {
+			printk(KERN_ERR "%s: Invalid port %d!\n", dev->name, port);
+			return NULL;
+		}
+		stats=&priv->wdslink[port-1].stats;
+	}
 	
-	return &priv->stats;
+	return stats;
 }
 
 struct iw_statistics *
@@ -2229,6 +2864,18 @@
 		return NULL; /* FIXME: Can we do better than this? */
 	}
 
+	if(dev != priv->ndev) {
+		int port=orinoco_lookup_port(dev);
+		
+		if((port<1) || (port>WDS_PORTS)) {
+			printk(KERN_ERR "%s: Invalid port %d!\n", dev->name, port);
+			return NULL;
+		}
+		wstats=&(priv->wdslink[port-1].wstats);
+		wstats->qual.qual=wstats->qual.level - wstats->qual.noise;
+		return wstats;
+	}
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return NULL; /* FIXME: Erg, we've been signalled, how
@@ -2320,15 +2967,21 @@
 	struct net_device_stats *stats = &priv->stats;
 	hermes_t *hw = &priv->hw;
 	int err = 0;
-	u16 txfid = priv->txfid;
+	u16 txfid = ORINOCO_DUMMY_FID;
 	char *p;
 	struct ethhdr *eh;
 	int len, data_len, data_off;
 	struct hermes_tx_descriptor desc;
 	unsigned long flags;
-
+	int port=0;
+	
 	TRACE_ENTER(dev->name);
 
+	if(dev->type != ARPHRD_ETHER) {
+		TRACE_EXIT(dev->name);
+		return 0;
+	}
+	
 	if (! netif_running(dev)) {
 		printk(KERN_ERR "%s: Tx on stopped device!\n",
 		       dev->name);
@@ -2343,6 +2996,17 @@
 		return 1;
 	}
 	
+	if(dev != priv->ndev) {
+		port=orinoco_lookup_port(dev);
+		
+		if((port<1) || (port>WDS_PORTS)) {
+			printk(KERN_ERR "%s: Tx on invalid port %d!\n", dev->name, port);
+			TRACE_EXIT(dev->name);
+			return 1;
+		}
+		stats=&(priv->wdslink[port-1].stats);
+	}
+	
 	if (orinoco_lock(priv, &flags) != 0) {
 		printk(KERN_ERR "%s: orinoco_xmit() called while hw_unavailable\n",
 		       dev->name);
@@ -2351,7 +3015,7 @@
 		return 1;
 	}
 
-	if (! priv->connected) {
+	if ((! priv->connected) && (!priv->ap_mode)) {
 		/* Oops, the firmware hasn't established a connection,
                    silently drop the packet (this seems to be the
                    safest approach). */
@@ -2362,6 +3026,16 @@
 		return 0;
 	}
 
+	txfid = orinoco_pop_txfid(priv);
+	if((txfid == ORINOCO_DUMMY_FID) || (!txfid)) {
+		printk(KERN_ERR"orinoco.c: WAAH! No TxFid left for %s!\n",dev->name);
+		stats->tx_errors++;
+		orinoco_unlock(priv, &flags);
+		dev_kfree_skb(skb);
+		TRACE_EXIT(dev->name);
+		return 0;
+	}
+	
 	/* Length of the packet body */
 	/* FIXME: what if the skb is smaller than this? */
 	len = max_t(int,skb->len - ETH_HLEN, ETH_ZLEN - ETH_HLEN);
@@ -2369,21 +3043,15 @@
 	eh = (struct ethhdr *)skb->data;
 
 	memset(&desc, 0, sizeof(desc));
- 	desc.tx_control = cpu_to_le16(HERMES_TXCTRL_TX_OK | HERMES_TXCTRL_TX_EX);
+ 	desc.tx_control = cpu_to_le16((port<<8) | HERMES_TXCTRL_TX_OK | HERMES_TXCTRL_TX_EX);
 	err = hermes_bap_pwrite(hw, USER_BAP, &desc, sizeof(desc), txfid, 0);
 	if (err) {
-		printk(KERN_ERR "%s: Error %d writing Tx descriptor to BAP\n",
-		       dev->name, err);
+		printk(KERN_ERR "%s: Error %d writing Tx descriptor %04X to BAP port %d\n",
+		       dev->name, err, txfid, port);
 		stats->tx_errors++;
 		goto fail;
 	}
 
-	/* Clear the 802.11 header and data length fields - some
-	 * firmwares (e.g. Lucent/Agere 8.xx) appear to get confused
-	 * if this isn't done. */
-	hermes_clear_words(hw, HERMES_DATA0,
-			   HERMES_802_3_OFFSET - HERMES_802_11_OFFSET);
-
 	/* Encapsulate Ethernet-II frames */
 	if (ntohs(eh->h_proto) > 1500) { /* Ethernet-II frame */
 		struct header_struct hdr;
@@ -2423,12 +3091,18 @@
 		goto fail;
 	}
 
-	/* Finally, we actually initiate the send */
-	netif_stop_queue(dev);
+	if(!priv->txfids) { /* No TXFids left -> stop queue(s) */
+		netif_stop_queue(priv->ndev);
+		for(port=0;port<WDS_PORTS;port++) {
+			if(priv->wdslink[port].dev.name[0]) {
+				netif_stop_queue(&priv->wdslink[port].dev);
+			} /* stop the queue */
+		} /* foreach WDSlink */
+	} /* no txfids left */
 
+	/* Finally, we actually initiate the send */
 	err = hermes_docmd_wait(hw, HERMES_CMD_TX | HERMES_CMD_RECL, txfid, NULL);
 	if (err) {
-		netif_start_queue(dev);
 		printk(KERN_ERR "%s: Error %d transmitting packet\n", dev->name, err);
 		stats->tx_errors++;
 		goto fail;
@@ -2439,36 +3113,63 @@
 
 	orinoco_unlock(priv, &flags);
 
-	DEV_KFREE_SKB(skb);
+	dev_kfree_skb(skb);
 
 	TRACE_EXIT(dev->name);
 
 	return 0;
  fail:
+	
+	orinoco_push_txfid(priv,txfid);
+	if(priv->txfids == 1) {
+		netif_wake_queue(priv->ndev);
+		for(port=0;port<WDS_PORTS;port++) {
+			if(priv->wdslink[port].dev.name[0]) {
+				netif_wake_queue(&priv->wdslink[port].dev);
+			} /* wake the queue */
+		} /* foreach WDSlink */
+	}
+	
 	TRACE_EXIT(dev->name);
 
 	orinoco_unlock(priv, &flags);
 	return err;
 }
 
-#ifdef HAVE_TX_TIMEOUT
-static void
-orinoco_tx_timeout(struct net_device *dev)
-{
+static void orinoco_tx_timeout(struct net_device *dev) {
 	struct orinoco_private *priv = (struct orinoco_private *)dev->priv;
 	struct net_device_stats *stats = &priv->stats;
 	struct hermes *hw = &priv->hw;
-
-	printk(KERN_WARNING "%s: Tx timeout! "
+	int port;
+	
+	printk(KERN_WARNING "%s: Tx timeout! %d free TxFIDs "
 	       "ALLOCFID=%04x, TXCOMPLFID=%04x, EVSTAT=%04x\n",
-	       dev->name, hermes_read_regn(hw, ALLOCFID),
+	       dev->name, priv->txfids, hermes_read_regn(hw, ALLOCFID),
 	       hermes_read_regn(hw, TXCOMPLFID), hermes_read_regn(hw, EVSTAT));
 
 	stats->tx_errors++;
-
-	schedule_work(&priv->reset_work);
+	
+	netif_stop_queue(priv->ndev);
+	for(port=0;port<WDS_PORTS;port++) {
+		if(priv->wdslink[port].dev.name[0]) {
+			netif_stop_queue(&priv->wdslink[port].dev);
+		}
+	} /* foreach WDSlink */
+	
+	orinoco_reset(dev);
+	
+	if (priv->hw_unavailable)
+		printk(KERN_ERR "%s: Error resetting card on Tx timeout!\n",
+		       dev->name);
+	else {
+		netif_wake_queue(priv->ndev);
+		for(port=0;port<WDS_PORTS;port++) {
+			if(priv->wdslink[port].dev.name[0]) {
+				netif_wake_queue(&priv->wdslink[port].dev);
+			}
+		} /* foreach WDSlink */
+	}
 }
-#endif
 
 static int
 orinoco_change_mtu(struct net_device *dev, int new_mtu)
@@ -2496,6 +3197,9 @@
 	int err = 0;
 	int promisc, mc_count;
 
+	if(priv->ap_mode)
+		return;
+	
 	/* The Hermes doesn't seem to have an allmulti mode, so we go
 	 * into promiscuous mode and let the upper levels deal. */
 	if ( (dev->flags & IFF_PROMISC) || (dev->flags & IFF_ALLMULTI) ||
@@ -2555,6 +3259,20 @@
 		dev->flags &= ~IFF_PROMISC;
 }
 
+static int orinoco_set_mac_address(struct net_device *dev, void *addr) {
+  struct orinoco_private *priv = dev->priv;
+  struct sockaddr *mac = addr;
+
+  /* Copy the address */
+  memcpy(dev->dev_addr, mac->sa_data, ETH_ALEN);
+
+  /* Reconfig the beast */
+  if((dev->type == ARPHRD_ETHER) && (!priv->ap_mode)) 
+	  orinoco_reconfigure(dev,0);
+
+  return 0;
+}
+
 /********************************************************************/
 /* Wireless extensions support                                      */
 /********************************************************************/
@@ -2595,25 +3313,18 @@
 
 	range.min_nwid = range.max_nwid = 0; /* We don't use nwids */
 
-	/* Set available channels/frequencies */
-	range.num_channels = NUM_CHANNELS;
-	k = 0;
-	for (i = 0; i < NUM_CHANNELS; i++) {
-		if (priv->channel_mask & (1 << i)) {
-			range.freq[k].i = i + 1;
-			range.freq[k].m = channel_frequency[i] * 100000;
-			range.freq[k].e = 1;
-			k++;
-		}
-		
-		if (k >= IW_MAX_FREQUENCIES)
-			break;
+	if((dev != priv->ndev) || ((mode == IW_MODE_INFRA) && (!(priv->ap_mode)))) {
+		range.max_qual.qual = 0x8b - 0x2f;
+		range.max_qual.level = 0x2f - 0x95 - 1;
+		range.max_qual.noise = 0x2f - 0x95 - 1;
+#if WIRELESS_EXT > 11
+		/* Need to get better values */
+		range.avg_qual.qual = 0x24;
+		range.avg_qual.level = 0xC2;
+		range.avg_qual.noise = 0x9E;
+#endif /* WIRELESS_EXT > 11 */
 	}
-	range.num_frequency = k;
-
-	range.sensitivity = 3;
-
-	if ((mode == IW_MODE_ADHOC) && (priv->spy_number == 0)){
+	else if (priv->spy_number == 0) {
 		/* Quality stats meaningless in ad-hoc mode */
 		range.max_qual.qual = 0;
 		range.max_qual.level = 0;
@@ -2623,21 +3334,10 @@
 		range.avg_qual.level = 0;
 		range.avg_qual.noise = 0;
 #endif /* WIRELESS_EXT > 11 */
-
-	} else {
-		range.max_qual.qual = 0x8b - 0x2f;
-		range.max_qual.level = 0x2f - 0x95 - 1;
-		range.max_qual.noise = 0x2f - 0x95 - 1;
-#if WIRELESS_EXT > 11
-		/* Need to get better values */
-		range.avg_qual.qual = 0x24;
-		range.avg_qual.level = 0xC2;
-		range.avg_qual.noise = 0x9E;
-#endif /* WIRELESS_EXT > 11 */
 	}
 
 	err = orinoco_hw_get_bitratelist(priv, &numrates,
-					 range.bitrate, IW_MAX_BITRATES);
+				       range.bitrate, IW_MAX_BITRATES);
 	if (err)
 		return err;
 	range.num_bitrates = numrates;
@@ -2654,25 +3354,6 @@
 	range.max_rts = 2347;
 	range.min_frag = 256;
 	range.max_frag = 2346;
-
-	err = orinoco_lock(priv, &flags);
-	if (err)
-		return err;
-	if (priv->has_wep) {
-		range.max_encoding_tokens = ORINOCO_MAX_KEYS;
-
-		range.encoding_size[0] = SMALL_KEY_SIZE;
-		range.num_encoding_sizes = 1;
-
-		if (priv->has_big_wep) {
-			range.encoding_size[1] = LARGE_KEY_SIZE;
-			range.num_encoding_sizes = 2;
-		}
-	} else {
-		range.num_encoding_sizes = 0;
-		range.max_encoding_tokens = 0;
-	}
-	orinoco_unlock(priv, &flags);
 		
 	range.min_pmp = 0;
 	range.max_pmp = 65535000;
@@ -2696,6 +3377,48 @@
 	range.max_r_time = 65535 * 1000;	/* ??? */
 #endif /* WIRELESS_EXT > 10 */
 
+	/* WDS */
+	if(dev != priv->ndev)
+		goto out;
+
+	/* Set available channels/frequencies */
+	range.num_channels = NUM_CHANNELS;
+	k = 0;
+	for (i = 0; i < NUM_CHANNELS; i++) {
+		if (priv->channel_mask & (1 << i)) {
+			range.freq[k].i = i + 1;
+			range.freq[k].m = channel_frequency[i] * 100000;
+			range.freq[k].e = 1;
+			k++;
+		}
+		
+		if (k >= IW_MAX_FREQUENCIES)
+			break;
+	}
+	range.num_frequency = k;
+
+	range.sensitivity = 3;
+
+	err = orinoco_lock(priv, &flags);
+	if (err)
+		return err;
+	if (priv->has_wep) {
+		range.max_encoding_tokens = ORINOCO_MAX_KEYS;
+
+		range.encoding_size[0] = SMALL_KEY_SIZE;
+		range.num_encoding_sizes = 1;
+
+		if (priv->has_big_wep) {
+			range.encoding_size[1] = LARGE_KEY_SIZE;
+			range.num_encoding_sizes = 2;
+		}
+	} else {
+		range.num_encoding_sizes = 0;
+		range.max_encoding_tokens = 0;
+	}
+	orinoco_unlock(priv, &flags);
+
+	out:
 	if (copy_to_user(rrq->pointer, &range, sizeof(range)))
 		return -EFAULT;
 
@@ -2856,6 +3579,10 @@
 	/* Note : ESSID is ignored in Ad-Hoc demo mode, but we can set it
 	 * anyway... - Jean II */
 
+	/* zero-length SSID (aka "Any") will fuck our card in AP mode */
+	if((priv->ap_mode) && ((erq->length)<=1))
+		return -EFAULT;
+	
 	memset(&essidbuf, 0, sizeof(essidbuf));
 
 	if (erq->flags) {
@@ -2904,7 +3631,7 @@
 	erq->flags = 1;
 	erq->length = strlen(essidbuf) + 1;
 	if (erq->pointer)
-		if (copy_to_user(erq->pointer, essidbuf, erq->length))
+		if ( copy_to_user(erq->pointer, essidbuf, erq->length) )
 			return -EFAULT;
 
 	TRACE_EXIT(dev->name);
@@ -2972,7 +3699,7 @@
 	/* We can only use this in Ad-Hoc demo mode to set the operating
 	 * frequency, or in IBSS mode to set the frequency where the IBSS
 	 * will be created - Jean II */
-	if (priv->iw_mode != IW_MODE_ADHOC)
+	if ((priv->iw_mode != IW_MODE_ADHOC) && (!priv->ap_mode) && (dev->type == ARPHRD_ETHER))
 		return -EOPNOTSUPP;
 
 	if ( (frq->e == 0) && (frq->m <= 1000) ) {
@@ -3012,7 +3739,7 @@
 	int err;
 	unsigned long flags;
 
-	if (!priv->has_sensitivity)
+	if ((!priv->has_sensitivity) && (!priv->ap_mode))
 		return -EOPNOTSUPP;
 
 	err = orinoco_lock(priv, &flags);
@@ -3037,7 +3764,7 @@
 	int err;
 	unsigned long flags;
 
-	if (!priv->has_sensitivity)
+	if ((!priv->has_sensitivity) && (!priv->ap_mode))
 		return -EOPNOTSUPP;
 
 	if ((val < 1) || (val > 3))
@@ -3056,7 +3783,7 @@
 {
 	struct orinoco_private *priv = dev->priv;
 	int val = rrq->value;
-	int err;
+	int err, port=0;
 	unsigned long flags;
 
 	if (rrq->disabled)
@@ -3065,11 +3792,24 @@
 	if ( (val < 0) || (val > 2347) )
 		return -EINVAL;
 
+	/* WDS dev */
+	if(dev != priv->ndev) {
+		port = orinoco_lookup_port(dev);
+		if((!port) || (port>WDS_PORTS))
+			return -EINVAL; /* shouldn't happen */
+		else if (port<0)
+			return port;
+	}
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
 
-	priv->rts_thresh = val;
+	if(!port)
+		priv->rts_thresh = val;
+	else
+		priv->wdslink[port-1].rts_thres=val;
+		
 	orinoco_unlock(priv, &flags);
 
 	return 0;
@@ -3154,9 +3894,18 @@
 	int err = 0;
 	int ratemode = -1;
 	int bitrate; /* 100s of kilobits */
-	int i;
+	int i, port=0;
 	unsigned long flags;
 	
+	/* WDS dev */
+	if(dev != priv->ndev) {
+		port = orinoco_lookup_port(dev);
+		if((!port) || (port>WDS_PORTS))
+			return -EINVAL; /* shouldn't happen */
+		else if (port<0)
+			return port;
+	}
+	
 	/* As the user space doesn't know our highest rate, it uses -1
 	 * to ask us to set the highest rate.  Test it using "iwconfig
 	 * ethX rate auto" - Jean II */
@@ -3185,7 +3934,10 @@
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
-	priv->bitratemode = ratemode;
+	if(!port)
+		priv->bitratemode = ratemode;
+	else
+		priv->wdslink[port-1].bitratemode = ratemode;
 	orinoco_unlock(priv, &flags);
 
 	return err;
@@ -3197,10 +3949,19 @@
 	hermes_t *hw = &priv->hw;
 	int err = 0;
 	int ratemode;
-	int i;
+	int i, port=0;
 	u16 val;
 	unsigned long flags;
 
+	/* WDS dev */
+	if(dev != priv->ndev) {
+		port = orinoco_lookup_port(dev);
+		if((!port) || (port>WDS_PORTS))
+			return -EINVAL; /* shouldn't happen */
+		else if (port<0)
+			return port;
+	}
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
@@ -3217,8 +3978,14 @@
 	/* If the interface is running we try to find more about the
 	   current mode */
 	if (netif_running(dev)) {
-		err = hermes_read_wordrec(hw, USER_BAP,
-					  HERMES_RID_CURRENTTXRATE, &val);
+		if(!port) {
+			err = hermes_read_wordrec(hw, USER_BAP,
+						  HERMES_RID_CURRENTTXRATE, &val);
+		}
+		else {
+			err = hermes_read_wordrec(hw, USER_BAP,
+						  HERMES_RID_CURRENTTXRATE1+port-1, &val);
+		}
 		if (err)
 			goto out;
 		
@@ -3233,7 +4000,7 @@
 				rrq->value = 5500000;
 			else
 				rrq->value = val * 1000000;
-			break;
+                        break;
 		case FIRMWARE_TYPE_INTERSIL: /* Intersil style rate */
 		case FIRMWARE_TYPE_SYMBOL: /* Symbol style rate */
 			for (i = 0; i < BITRATE_TABLE_SIZE; i++)
@@ -3264,6 +4031,9 @@
 	int err = 0;
 	unsigned long flags;
 
+	if(priv->ap_mode)
+		return -EINVAL;
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
@@ -3319,6 +4089,9 @@
 	u16 enable, period, timeout, mcast;
 	unsigned long flags;
 
+	if(priv->ap_mode)
+		return -EINVAL;
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
@@ -3421,6 +4194,9 @@
 	int err;
 	unsigned long flags;
 
+	if(priv->ap_mode)
+		return -EINVAL;
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
@@ -3441,6 +4217,9 @@
 	int err;
 	unsigned long flags;
 
+	if(priv->ap_mode)
+		return -EINVAL;
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
@@ -3458,6 +4237,9 @@
 	int err = 0;
 	unsigned long flags;
 
+	if(priv->ap_mode)
+		return -EINVAL;
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
@@ -3500,6 +4282,9 @@
 	int err;
 	unsigned long flags;
 
+	if(priv->ap_mode)
+		return -EINVAL;
+	
 	err = orinoco_lock(priv, &flags);
 	if (err)
 		return err;
@@ -3605,6 +4390,80 @@
 	return 0;
 }
 
+static int orinoco_ioctl_wds(struct net_device *dev, struct ifreq *rq, int cmd) {
+	struct orinoco_private *priv = dev->priv;
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int port, res=0, changed=0;
+	
+	if (! netif_device_present(dev))
+		return -ENODEV;
+	
+	port=orinoco_lookup_port(dev);
+	if((port<1) || (port>WDS_PORTS))
+		return -EINVAL; /* shouldn't happen */
+	port--;
+	
+	switch (cmd) {
+	case SIOCGIWNAME:
+		strcpy(wrq->u.name, "IEEE 802.11-DS");
+		break;
+	
+	case SIOCGIWAP:
+		wrq->u.ap_addr.sa_family = ARPHRD_ETHER;
+		memcpy(wrq->u.ap_addr.sa_data,priv->wdslink[port].peer_addr,ETH_ALEN);
+		break;
+	
+	case SIOCSIWAP:
+		if (! capable(CAP_NET_ADMIN)) {
+			res = -EPERM;
+			break;
+		}
+		memcpy(priv->wdslink[port].peer_addr,wrq->u.ap_addr.sa_data,ETH_ALEN);
+		changed=1;
+		break;
+	
+	case SIOCGIWRANGE:
+		res = orinoco_ioctl_getiwrange(dev, &wrq->u.data);
+		break;
+	
+	case SIOCGIWMODE:
+		wrq->u.mode=IW_MODE_REPEAT;
+		break;
+	
+	case SIOCGIWRTS:
+		wrq->u.rts.value = priv->wdslink[port].rts_thres;
+		wrq->u.rts.disabled = (wrq->u.rts.value == 2347);
+		wrq->u.rts.fixed = 1;
+		break;
+
+	case SIOCSIWRTS:
+		res = orinoco_ioctl_setrts(dev, &wrq->u.rts);
+		if (! res)
+			changed = 1;
+		break;
+
+	case SIOCSIWRATE:
+		res = orinoco_ioctl_setrate(dev, &wrq->u.bitrate);
+		if (! res)
+			changed = 1;
+		break;
+
+	case SIOCGIWRATE:
+		res = orinoco_ioctl_getrate(dev, &wrq->u.bitrate);
+		break;
+
+	default:
+		res = -EINVAL;
+		break;
+	}
+	
+	if (! res && changed && netif_running(dev)) {
+		res = orinoco_reconfigure(dev, 0);
+	}
+	
+	return res;
+}
+
 static int
 orinoco_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
@@ -3612,7 +4471,7 @@
 	struct iwreq *wrq = (struct iwreq *)rq;
 	int err = 0;
 	int tmp;
-	int changed = 0;
+	int changed = 0, monitor_disable=0;
 	unsigned long flags;
 
 	TRACE_ENTER(dev->name);
@@ -3625,7 +4484,7 @@
 	 * already ready...  Jean II */
 	if (! netif_device_present(dev))
 		return -ENODEV;
-
+	
 	switch (cmd) {
 	case SIOCGIWNAME:
 		strcpy(wrq->u.name, "IEEE 802.11-DS");
@@ -3650,28 +4509,62 @@
 				err = -EINVAL;
 			else {
 				priv->iw_mode = IW_MODE_ADHOC;
+				if(dev->type != ARPHRD_ETHER)
+					monitor_disable=1;
 				changed = 1;
 			}
 			break;
 
 		case IW_MODE_INFRA:
 			priv->iw_mode = IW_MODE_INFRA;
+			if(dev->type != ARPHRD_ETHER)
+				monitor_disable=1;
 			changed = 1;
 			break;
+		
+		case IW_MODE_MASTER:
+			if(!(priv->ap_mode))
+				err = -EINVAL;
+			break;
 
+#if WIRELESS_EXT >= 15
+		case IW_MODE_MONITOR:
+			if(dev->type == ARPHRD_ETHER)
+				changed=1;
+			dev->type = ARPHRD_IEEE80211;
+			break;
+#endif /* WIRELESS_EXT >= 15 */
+			
 		default:
 			err = -EINVAL;
 			break;
 		}
 		set_port_type(priv);
 		orinoco_unlock(priv, &flags);
+		if((priv->ap_mode) && (changed)) {
+			/* hard reset necessary to switch back to non-TER fw */
+			priv->ap_mode|=ORINOCO_AP_LEAVE;
+			orinoco_reset(priv->ndev);
+			changed=0;
+			if(priv->ap_mode) /* no hard reset done - can't kill TER fw */
+				err=-EFAULT;
+		}
 		break;
 
 	case SIOCGIWMODE:
 		err = orinoco_lock(priv, &flags);
 		if (err)
 			return err;
-		wrq->u.mode = priv->iw_mode;
+		if(dev->type != ARPHRD_ETHER)
+#if WIRELESS_EXT >= 15
+			wrq->u.mode = IW_MODE_MONITOR;
+#else
+			wrq->u.mode = IW_MODE_ADHOC;
+#endif
+		else if(priv->ap_mode)
+			wrq->u.mode = IW_MODE_MASTER;
+		else
+			wrq->u.mode = priv->iw_mode;
 		orinoco_unlock(priv, &flags);
 		break;
 
@@ -3837,7 +4730,21 @@
 				{ SIOCIWFIRSTPRIV + 0x7, 0,
 				  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
 				  "get_ibssport" },
-				{ SIOCIWLASTPRIV, 0, 0, "dump_recs" },
+				  { SIOCIWFIRSTPRIV + 0x8,
+				  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+				  0, "hidden" },
+				  { SIOCIWFIRSTPRIV + 0x9, 0,
+				  IW_PRIV_TYPE_CHAR | IFNAMSIZ, "add_wds" },
+				  { SIOCIWFIRSTPRIV + 0xA,
+				  IW_PRIV_TYPE_CHAR | IFNAMSIZ, 
+				  0, "del_wds" },
+				  { SIOCIWFIRSTPRIV + 0xb, 0,
+				  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+				  "free_txfids" },
+				  { SIOCIWFIRSTPRIV + 0xc,
+				  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+				  0, "monitor" },
+				{ SIOCIWLASTPRIV, 0, 0, "dump_rids" },
 			};
 
 			err = verify_area(VERIFY_WRITE, wrq->u.data.pointer, sizeof(privtab));
@@ -3859,7 +4766,7 @@
 		
 		printk(KERN_DEBUG "%s: Force scheduling reset!\n", dev->name);
 
-		schedule_work(&priv->reset_work);
+		schedule_work(&priv->timeout_task);
 		break;
 
 	case SIOCIWFIRSTPRIV + 0x2: /* set_port3 */
@@ -3883,6 +4790,11 @@
 			break;
 		}
 
+		if(priv->ap_mode) {
+			err = -EINVAL;
+			break;
+		}
+		
 		/* 802.11b has recently defined some short preamble.
 		 * Basically, the Phy header has been reduced in size.
 		 * This increase performance, especially at high rates
@@ -3905,6 +4817,11 @@
 		break;
 
 	case SIOCIWFIRSTPRIV + 0x5: /* get_preamble */
+		if(priv->ap_mode) {
+			err = -EINVAL;
+			break;
+		}
+	
 		if(priv->has_preamble) {
 			int *val = (int *)wrq->u.name;
 
@@ -3931,204 +4848,259 @@
 		err = orinoco_ioctl_getibssport(dev, wrq);
 		break;
 
+	case SIOCIWFIRSTPRIV + 0x8: /* hidden mode */
+		if (! capable(CAP_NET_ADMIN)) {
+			err = -EPERM;
+			break;
+		}
+		
+		if(!(priv->ap_mode)) {
+			err = -EINVAL;
+			break;
+		}
+		
+		if(wrq->u.name[0]) { /* enable */
+			if(!(priv->ap_mode&ORINOCO_AP_HIDDEN)) {
+				/* change */
+				priv->ap_mode|=ORINOCO_AP_HIDDEN;
+				changed=1;
+			}
+		}
+		else {
+			if(priv->ap_mode&ORINOCO_AP_HIDDEN) {
+				/* change */
+				priv->ap_mode&=~ORINOCO_AP_HIDDEN;
+				changed=1;
+			}
+		}
+		break;
+		
+	case SIOCIWFIRSTPRIV + 0x9: /* add_wds */
+		if (! capable(CAP_NET_ADMIN)) {
+			err = -EPERM;
+			break;
+		}
+		
+		if(!(priv->ap_mode)) {
+			err = -EINVAL;
+			break;
+		}
+				
+		err = orinoco_lock(priv, &flags);
+		if (err)
+			break;
+		
+		for(tmp=0;tmp<WDS_PORTS;tmp++) {
+				if(!priv->wdslink[tmp].dev.name[0]) {
+					struct net_device *wdev=&priv->wdslink[tmp].dev;
+					int kaunt=0;
+					
+					wdev->priv=priv;
+					priv->wdslink[tmp].info=0;
+					
+					/* we use the values from port 0 as default */
+					priv->wdslink[tmp].rts_thres=priv->rts_thresh;
+					priv->wdslink[tmp].bitratemode=priv->bitratemode;
+					
+					/* Setup / override net_device fields */
+					ether_setup(wdev);
+					
+					//wdev->init = orinoco_init;
+					
+					memcpy(wdev->dev_addr,dev->dev_addr,ETH_ALEN);
+					
+					wdev->base_addr = dev->base_addr;
+					wdev->irq = dev->irq;
+					wdev->mem_start = dev->mem_start;
+					wdev->mem_end = dev->mem_end;
+					
+					wdev->hard_start_xmit = orinoco_xmit;
+					wdev->tx_timeout = orinoco_tx_timeout;
+					wdev->watchdog_timeo = HZ; /* 1 second timeout */
+					wdev->get_stats = orinoco_get_stats;
+					
+					wdev->get_wireless_stats = orinoco_get_wireless_stats;
+					
+					wdev->do_ioctl = orinoco_ioctl_wds;
+					wdev->change_mtu = orinoco_change_mtu;
+					//wdev->set_multicast_list = orinoco_set_multicast_list;
+
+					wdev->set_mac_address = orinoco_set_mac_address;
+
+					/* Set up default callbacks */
+					wdev->open = orinoco_open;
+					wdev->stop = orinoco_stop;
+					
+					SET_MODULE_OWNER(wdev);
+					
+					/* completely stolen from HostAP - thnx Jouni! 8-) */
+					do {
+						sprintf(wdev->name,"eth%d",kaunt++);
+					} while (kaunt < 10000 && dev_get(wdev->name));
+					
+					err = register_netdevice(wdev);
+					if(err) {
+						memset(priv->wdslink+tmp,0,sizeof(struct wdslink));
+						printk(KERN_ERR"orinoco: adding WDSlink for %s port %d failed: %d\n",dev->name,tmp+1,err);
+					}
+					else
+						printk(KERN_INFO "orinoco: WDSlink %s registered for %s port %d\n",wdev->name,dev->name,tmp+1);
+					err = copy_to_user(wrq->u.data.pointer,wdev->name,IFNAMSIZ);
+					break;
+				}
+		}
+		orinoco_unlock(priv, &flags);
+		if(tmp == WDS_PORTS)
+			err = -EINVAL;
+		
+		break;
+	case SIOCIWFIRSTPRIV + 0xa: { /* del_wds */
+		char tmpname[IFNAMSIZ];
+		
+		if (! capable(CAP_NET_ADMIN)) {
+			err = -EPERM;
+			break;
+		}
+		
+		if(!(priv->ap_mode)) {
+			err = -EINVAL;
+			break;
+		}
+				
+		if(!wrq->u.data.pointer) {
+			err = -EINVAL;
+			break;
+		}
+		
+		if(copy_from_user(tmpname,wrq->u.data.pointer,IFNAMSIZ)) {
+			err = -EFAULT;
+			break;
+		}
+		
+		if(!tmpname[0]) {
+			err = -EINVAL;
+			break;
+		}
+		
+		err = orinoco_lock(priv, &flags);
+		if (err)
+			break;
+		
+		for(tmp=0;tmp<WDS_PORTS;tmp++) {
+				if(!(strcmp(priv->wdslink[tmp].dev.name,tmpname))) {
+					if(priv->wdslink[tmp].info&WDS_INFO_OPEN)
+						err=-EBUSY; /* or shall I just shutdown the dev myself? */
+					else {
+						unregister_netdevice(&(priv->wdslink[tmp].dev));
+						printk(KERN_DEBUG"orinoco: removed WDSlink %s from port %d of %s\n",priv->wdslink[tmp].dev.name,tmp+1,dev->name);
+						/* clean up */
+						memset(priv->wdslink+tmp,0,sizeof(struct wdslink));
+					}
+					break;
+				}
+		}
+		orinoco_unlock(priv, &flags);
+		if(tmp == WDS_PORTS)
+			err = -EINVAL;
+		break;
+	}
+	
+	case SIOCIWFIRSTPRIV + 0xB: /* free txfids */
+		
+		if (! capable(CAP_NET_ADMIN)) {
+			err = -EPERM;
+			break;
+		}
+
+		/* no locking done here since it's a just a
+		   informational readonly low priority user request */
+		*((int *)wrq->u.name)=priv->txfids;
+		
+		break;
+	
+	case SIOCIWFIRSTPRIV + 0xC: /* monitoring */
+		if (! capable(CAP_NET_ADMIN)) {
+			err = -EPERM;
+			break;
+		}
+		
+		if((!wrq->u.name[0]) && (dev->type != ARPHRD_ETHER)) {
+			monitor_disable=1;
+			changed=1;
+		}
+		else if ((wrq->u.name[0]) && (dev->type == ARPHRD_ETHER)) {
+			if (wrq->u.name[0] == 1)
+				dev->type = ARPHRD_IEEE80211_PRISM;
+			else 
+				dev->type = ARPHRD_IEEE80211;
+			changed=1;
+		}
+
+		if((dev->type!=ARPHRD_ETHER) && (priv->ap_mode)) {
+			/* hard reset necessary to switch back to non-TER fw */
+			priv->ap_mode|=ORINOCO_AP_LEAVE;
+			orinoco_reset(priv->ndev);
+			changed=0;
+			if(priv->ap_mode) /* no hard reset done - can't kill TER fw */
+				err=-EFAULT;
+		}
+		break;
+
 	case SIOCIWLASTPRIV:
-		err = orinoco_debug_dump_recs(dev);
+		err = orinoco_debug_dump_rids(priv);
 		if (err)
-			printk(KERN_ERR "%s: Unable to dump records (%d)\n",
+			printk(KERN_ERR "%s: Unable to dump rids (%d)\n",
 			       dev->name, err);
 		break;
 
-
 	default:
 		err = -EOPNOTSUPP;
 	}
 	
-	if (! err && changed && netif_running(dev)) {
-		err = orinoco_reconfigure(dev);
-	}		
-
+	if ((! err) && changed && (netif_running(dev) || (priv->ap_mode) || (monitor_disable)))
+		err = orinoco_reconfigure(dev, monitor_disable);
+	
 	TRACE_EXIT(dev->name);
 
 	return err;
 }
 
-struct {
-	u16 rid;
-	char *name;
-	int displaytype;
-#define DISPLAY_WORDS	0
-#define DISPLAY_BYTES	1
-#define DISPLAY_STRING	2
-#define DISPLAY_XSTRING	3
-} record_table[] = {
-#define DEBUG_REC(name,type) { HERMES_RID_##name, #name, DISPLAY_##type }
-	DEBUG_REC(CNFPORTTYPE,WORDS),
-	DEBUG_REC(CNFOWNMACADDR,BYTES),
-	DEBUG_REC(CNFDESIREDSSID,STRING),
-	DEBUG_REC(CNFOWNCHANNEL,WORDS),
-	DEBUG_REC(CNFOWNSSID,STRING),
-	DEBUG_REC(CNFOWNATIMWINDOW,WORDS),
-	DEBUG_REC(CNFSYSTEMSCALE,WORDS),
-	DEBUG_REC(CNFMAXDATALEN,WORDS),
-	DEBUG_REC(CNFPMENABLED,WORDS),
-	DEBUG_REC(CNFPMEPS,WORDS),
-	DEBUG_REC(CNFMULTICASTRECEIVE,WORDS),
-	DEBUG_REC(CNFMAXSLEEPDURATION,WORDS),
-	DEBUG_REC(CNFPMHOLDOVERDURATION,WORDS),
-	DEBUG_REC(CNFOWNNAME,STRING),
-	DEBUG_REC(CNFOWNDTIMPERIOD,WORDS),
-	DEBUG_REC(CNFMULTICASTPMBUFFERING,WORDS),
-	DEBUG_REC(CNFWEPENABLED_AGERE,WORDS),
-	DEBUG_REC(CNFMANDATORYBSSID_SYMBOL,WORDS),
-	DEBUG_REC(CNFWEPDEFAULTKEYID,WORDS),
-	DEBUG_REC(CNFDEFAULTKEY0,BYTES),
-	DEBUG_REC(CNFDEFAULTKEY1,BYTES),
-	DEBUG_REC(CNFMWOROBUST_AGERE,WORDS),
-	DEBUG_REC(CNFDEFAULTKEY2,BYTES),
-	DEBUG_REC(CNFDEFAULTKEY3,BYTES),
-	DEBUG_REC(CNFWEPFLAGS_INTERSIL,WORDS),
-	DEBUG_REC(CNFWEPKEYMAPPINGTABLE,WORDS),
-	DEBUG_REC(CNFAUTHENTICATION,WORDS),
-	DEBUG_REC(CNFMAXASSOCSTA,WORDS),
-	DEBUG_REC(CNFKEYLENGTH_SYMBOL,WORDS),
-	DEBUG_REC(CNFTXCONTROL,WORDS),
-	DEBUG_REC(CNFROAMINGMODE,WORDS),
-	DEBUG_REC(CNFHOSTAUTHENTICATION,WORDS),
-	DEBUG_REC(CNFRCVCRCERROR,WORDS),
-	DEBUG_REC(CNFMMLIFE,WORDS),
-	DEBUG_REC(CNFALTRETRYCOUNT,WORDS),
-	DEBUG_REC(CNFBEACONINT,WORDS),
-	DEBUG_REC(CNFAPPCFINFO,WORDS),
-	DEBUG_REC(CNFSTAPCFINFO,WORDS),
-	DEBUG_REC(CNFPRIORITYQUSAGE,WORDS),
-	DEBUG_REC(CNFTIMCTRL,WORDS),
-	DEBUG_REC(CNFTHIRTY2TALLY,WORDS),
-	DEBUG_REC(CNFENHSECURITY,WORDS),
-	DEBUG_REC(CNFGROUPADDRESSES,BYTES),
-	DEBUG_REC(CNFCREATEIBSS,WORDS),
-	DEBUG_REC(CNFFRAGMENTATIONTHRESHOLD,WORDS),
-	DEBUG_REC(CNFRTSTHRESHOLD,WORDS),
-	DEBUG_REC(CNFTXRATECONTROL,WORDS),
-	DEBUG_REC(CNFPROMISCUOUSMODE,WORDS),
-	DEBUG_REC(CNFBASICRATES_SYMBOL,WORDS),
-	DEBUG_REC(CNFPREAMBLE_SYMBOL,WORDS),
-	DEBUG_REC(CNFSHORTPREAMBLE,WORDS),
-	DEBUG_REC(CNFWEPKEYS_AGERE,BYTES),
-	DEBUG_REC(CNFEXCLUDELONGPREAMBLE,WORDS),
-	DEBUG_REC(CNFTXKEY_AGERE,WORDS),
-	DEBUG_REC(CNFAUTHENTICATIONRSPTO,WORDS),
-	DEBUG_REC(CNFBASICRATES,WORDS),
-	DEBUG_REC(CNFSUPPORTEDRATES,WORDS),
-	DEBUG_REC(CNFTICKTIME,WORDS),
-	DEBUG_REC(CNFSCANREQUEST,WORDS),
-	DEBUG_REC(CNFJOINREQUEST,WORDS),
-	DEBUG_REC(CNFAUTHENTICATESTATION,WORDS),
-	DEBUG_REC(CNFCHANNELINFOREQUEST,WORDS),
-	DEBUG_REC(MAXLOADTIME,WORDS),
-	DEBUG_REC(DOWNLOADBUFFER,WORDS),
-	DEBUG_REC(PRIID,WORDS),
-	DEBUG_REC(PRISUPRANGE,WORDS),
-	DEBUG_REC(CFIACTRANGES,WORDS),
-	DEBUG_REC(NICSERNUM,XSTRING),
-	DEBUG_REC(NICID,WORDS),
-	DEBUG_REC(MFISUPRANGE,WORDS),
-	DEBUG_REC(CFISUPRANGE,WORDS),
-	DEBUG_REC(CHANNELLIST,WORDS),
-	DEBUG_REC(REGULATORYDOMAINS,WORDS),
-	DEBUG_REC(TEMPTYPE,WORDS),
-/*  	DEBUG_REC(CIS,BYTES), */
-	DEBUG_REC(STAID,WORDS),
-	DEBUG_REC(CURRENTSSID,STRING),
-	DEBUG_REC(CURRENTBSSID,BYTES),
-	DEBUG_REC(COMMSQUALITY,WORDS),
-	DEBUG_REC(CURRENTTXRATE,WORDS),
-	DEBUG_REC(CURRENTBEACONINTERVAL,WORDS),
-	DEBUG_REC(CURRENTSCALETHRESHOLDS,WORDS),
-	DEBUG_REC(PROTOCOLRSPTIME,WORDS),
-	DEBUG_REC(SHORTRETRYLIMIT,WORDS),
-	DEBUG_REC(LONGRETRYLIMIT,WORDS),
-	DEBUG_REC(MAXTRANSMITLIFETIME,WORDS),
-	DEBUG_REC(MAXRECEIVELIFETIME,WORDS),
-	DEBUG_REC(CFPOLLABLE,WORDS),
-	DEBUG_REC(AUTHENTICATIONALGORITHMS,WORDS),
-	DEBUG_REC(PRIVACYOPTIONIMPLEMENTED,WORDS),
-	DEBUG_REC(OWNMACADDR,BYTES),
-	DEBUG_REC(SCANRESULTSTABLE,WORDS),
-	DEBUG_REC(PHYTYPE,WORDS),
-	DEBUG_REC(CURRENTCHANNEL,WORDS),
-	DEBUG_REC(CURRENTPOWERSTATE,WORDS),
-	DEBUG_REC(CCAMODE,WORDS),
-	DEBUG_REC(SUPPORTEDDATARATES,WORDS),
-	DEBUG_REC(BUILDSEQ,BYTES),
-	DEBUG_REC(FWID,XSTRING)
-#undef DEBUG_REC
-};
-
 #define DEBUG_LTV_SIZE		128
 
-static int orinoco_debug_dump_recs(struct net_device *dev)
+static int orinoco_debug_dump_rids(struct orinoco_private *priv)
 {
-	struct orinoco_private *priv = dev->priv;
 	hermes_t *hw = &priv->hw;
 	u8 *val8;
-	u16 *val16;
-	int i,j;
-	u16 length;
-	int err;
+	u16 rid, length;
+	int len,i,err;
 
 	/* I'm not sure: we might have a lock here, so we'd better go
            atomic, just in case. */
 	val8 = kmalloc(DEBUG_LTV_SIZE + 2, GFP_ATOMIC);
 	if (! val8)
 		return -ENOMEM;
-	val16 = (u16 *)val8;
-
-	for (i = 0; i < ARRAY_SIZE(record_table); i++) {
-		u16 rid = record_table[i].rid;
-		int len;
 
-		memset(val8, 0, DEBUG_LTV_SIZE + 2);
-
-		err = hermes_read_ltv(hw, USER_BAP, rid, DEBUG_LTV_SIZE,
-				      &length, val8);
-		if (err) {
+	for(rid=0xFC00; rid<0xFE00; rid++) {
+		
+		err = hermes_read_ltv(hw, USER_BAP, rid, DEBUG_LTV_SIZE, &length, val8);
+		
+		if(err) {
 			DEBUG(0, "Error %d reading RID 0x%04x\n", err, rid);
 			continue;
 		}
-		val16 = (u16 *)val8;
-		if (length == 0)
+		
+		if(!length)
 			continue;
-
-		printk(KERN_DEBUG "%-15s (0x%04x): length=%d (%d bytes)\tvalue=",
-		       record_table[i].name,
-		       rid, length, (length-1)*2);
-		len = min(((int)length-1)*2, DEBUG_LTV_SIZE);
-
-		switch (record_table[i].displaytype) {
-		case DISPLAY_WORDS:
-			for (j = 0; j < len / 2; j++)
-				printk("%04X-", le16_to_cpu(val16[j]));
-			break;
-
-		case DISPLAY_BYTES:
-		default:
-			for (j = 0; j < len; j++)
-				printk("%02X:", val8[j]);
-			break;
-
-		case DISPLAY_STRING:
-			len = min(len, le16_to_cpu(val16[0])+2);
-			val8[len] = '\0';
-			printk("\"%s\"", (char *)&val16[1]);
-			break;
-
-		case DISPLAY_XSTRING:
-			printk("'%s'", (char *)val8);
-		}
-
+		
+		len = min(((int)length-1)<<1, DEBUG_LTV_SIZE);
+		
+		printk(KERN_DEBUG"%s: %04X %d: ",priv->ndev->name,rid,len);
+		for(i=0;i<(len>>1);i++)
+			printk("%04X ",(u16)val8[i]);
 		printk("\n");
+		
 	}
-
+	
 	kfree(val8);
 
 	return 0;
@@ -4150,17 +5122,16 @@
 	/* Setup / override net_device fields */
 	dev->init = orinoco_init;
 	dev->hard_start_xmit = orinoco_xmit;
-#ifdef HAVE_TX_TIMEOUT
 	dev->tx_timeout = orinoco_tx_timeout;
 	dev->watchdog_timeo = HZ; /* 1 second timeout */
-#endif
 	dev->get_stats = orinoco_get_stats;
 	dev->get_wireless_stats = orinoco_get_wireless_stats;
 	dev->do_ioctl = orinoco_ioctl;
 	dev->change_mtu = orinoco_change_mtu;
 	dev->set_multicast_list = orinoco_set_multicast_list;
-	/* we use the default eth_mac_addr for setting the MAC addr */
 
+	dev->set_mac_address = orinoco_set_mac_address;
+	
 	/* Set up default callbacks */
 	dev->open = orinoco_open;
 	dev->stop = orinoco_stop;
@@ -4171,7 +5142,7 @@
 	priv->hw_unavailable = 1; /* orinoco_init() must clear this
 				   * before anything else touches the
 				   * hardware */
-	INIT_WORK(&priv->reset_work, (void (*)(void *))orinoco_reset, dev);
+	INIT_WORK(&priv->timeout_task, (void (*)(void *))orinoco_reset, dev);
 
 	priv->last_linkstatus = 0xffff;
 	priv->connected = 0;
@@ -4180,6 +5151,549 @@
 
 }
 
+/* mem_dev stuff */
+
+int orinoco_mem_dev_init(struct orinoco_private *priv) {
+	int i;
+	
+	priv->mem_open=0;
+	priv->dl_pid=0;
+	
+	for(i = 0; i < ORINOCO_MAX_DEVICES; i++)
+	{
+		if (orinoco_dev_priv[i] == 0)
+		{
+			orinoco_dev_priv[i] = priv;
+			break;
+		}
+	}
+	
+	if (i < ORINOCO_MAX_DEVICES)
+		printk ("orinoco: registered new device as minor %d\n", i);
+
+	return 0;
+}
+
+void orinoco_mem_dev_cleanup(struct orinoco_private *priv) {
+	int i;
+
+	for (i = 0; i < ORINOCO_MAX_DEVICES; i++)
+		if (orinoco_dev_priv[i] == priv)
+		{
+			printk("orinoco: freed device minor %d\n", i);
+			orinoco_dev_priv[i] = 0;
+		}
+}
+
+static int orinoco_mem_open (struct inode *inode, struct file *file) {
+	struct orinoco_private *priv;
+	hermes_t *hw;
+
+	unsigned long flags;
+	int res=0;
+	int minor;
+
+	minor = MINOR(inode->i_rdev);
+/*
+	printk ("orinoco: trying to open device %d:%d, contents 0x%x\n",
+		MAJOR(inode->i_dev), minor, orinoco_dev_priv[minor]);
+*/
+	if (orinoco_dev_priv[minor] == 0)
+		return -ENOTTY;
+
+	priv = (struct orinoco_private *)orinoco_dev_priv[minor];
+	hw = &priv->hw;
+		
+	res = orinoco_lock(priv, &flags);	/* ##### LOCK ##### */
+	if(res)
+		return res;
+	
+	/* enable AUX port if not yet done (1st open) */
+	if (!(priv->mem_open))
+		res=hermes_aux_cntl(hw,1);
+	
+	if(!res)
+		priv->mem_open++;
+	
+	orinoco_unlock(priv, &flags); /* ##### UNLOCK ##### */
+	
+	return res;
+}
+
+static int orinoco_mem_close(struct inode *inode, struct file *file) {
+	struct orinoco_private *priv;
+	hermes_t *hw;
+	unsigned long flags;
+	int minor;
+
+	minor = MINOR(inode->i_rdev);
+	if (orinoco_dev_priv[minor] == 0)
+		return -ENOTTY;
+
+	priv = (struct orinoco_private *)orinoco_dev_priv[minor];
+	hw = &priv->hw;
+	
+	spin_lock_irqsave(&priv->lock, flags); /* ##### LOCK ##### */
+	
+	priv->mem_open--;
+	
+	/* disable AUX port if we're the last process accessing it */
+	if((!priv->mem_open) && (!priv->hw_unavailable) && (hermes_aux_enabled(hw)))
+		hermes_aux_cntl(hw,0);
+	
+	/* that WIMP got cold feet and LEFT US WITHOUT ACKing the firmware
+	   download - do our best to abort it */
+	if(priv->dl_pid == current->pid) {
+		
+		if(!priv->hw_unavailable) {
+			spin_unlock_irqrestore(&priv->lock, flags);
+			orinoco_reset(priv->ndev); /* no better idea how to abort the download without booting the new FW */
+			spin_lock_irqsave(&priv->lock, flags);
+	
+			if(priv->mem_open) /* device still open therefor we */
+				hermes_aux_cntl(hw,1); /* try to reenable the AUX port */
+		} /* if hw avail */
+		
+		priv->dl_pid=0; /* allow firmware downloads again */
+	}
+	
+	spin_unlock_irqrestore(&priv->lock, flags); /* ##### UNLOCK ##### */
+	
+	return 0;
+}
+
+static int orinoco_mem_ioctl (struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg) {
+	struct orinoco_private *priv;
+	hermes_t *hw;
+	unsigned long flags;
+	int res=0;
+	int minor;
+
+	minor = MINOR(inode->i_rdev);
+	if (orinoco_dev_priv[minor] == 0)
+		return -ENOTTY;
+
+	priv = (struct orinoco_private *)orinoco_dev_priv[minor];
+	hw = &priv->hw;
+	
+	/* check if AUX port enabled / device ok */
+	if(!hermes_aux_enabled(hw))
+		return -ENODEV;
+	
+	switch(cmd) {
+		
+		/* firmware download to ram request */
+		case ORINOCO_PREPARE_RAMDL:
+			
+			/* ### NOTE: - arg is the entry point of the firmware
+				             - it's in HOST-ENDIAN!!
+				               (will automatically be converted to little endian for the card)
+				             - and it must be EVEN!! */
+							   
+			/* write access needed for this */
+			if((file->f_flags&O_ACCMODE)==O_RDONLY)
+				return -EPERM;
+
+			res=orinoco_lock(priv, &flags); /* ##### LOCK ##### */
+			if(res)
+				return res;
+			
+			if(priv->dl_pid)      /* already a firmware download in progress? */
+				res=-EINVAL;
+			
+			else if((priv->open) || (orinoco_wds_active(priv))) /* netdev active? */
+				res=-EBUSY;
+			
+			else if(!(res=hermes_boot_request(hw, arg))) /* so far, so good - kindly ask the card to do as we wish */
+				priv->dl_pid=current->pid; /* got an ok from the card - lock it */
+			
+			orinoco_unlock(priv, &flags); /* ##### UNLOCK ##### */
+			
+		break;
+		
+		/* download to ram finished */
+		case ORINOCO_FINISH_RAMDL:
+			
+			/* write access needed for this */
+			if((file->f_flags&O_ACCMODE)==O_RDONLY)
+				return -EPERM;
+			
+			/* only the process who successfully requested firmware download may ACK it */
+			if(current->pid != priv->dl_pid)
+				return -EINVAL;
+
+			res=orinoco_lock(priv, &flags); /* ##### LOCK ##### */
+			if(res)
+				return res;
+			
+			res=hermes_boot_ack(hw); /* tell the card we're done */
+			
+			if(!res)
+				orinoco_init(priv->ndev); /* if we get an OK from card -> reinitialize it */
+			
+			/* try to reenable the AUX port since device is open - or how did we get our ioctl? ;) */
+			hermes_aux_cntl(hw,1);
+			
+			orinoco_unlock(priv, &flags); /* ##### UNLOCK ##### */
+			
+			priv->dl_pid=0; /* unlock card - allow firmware upload requests + netdev up again */
+		break;
+		
+		default:
+			return -EINVAL;
+	}
+	return res;
+}
+
+static ssize_t orinoco_mem_read (struct file *file, char *buf, size_t count, loff_t *offset) {
+	struct orinoco_private *priv;
+	hermes_t *hw;
+	unsigned long flags;
+	u16 pagebuf[HERMES_AUX_PAGESIZE>>1];
+	char *pb=buf;
+	int cnt, cnt2, res=0;
+	int minor;
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	if (orinoco_dev_priv[minor] == 0)
+		return -ENOTTY;
+
+	priv = (struct orinoco_private *)orinoco_dev_priv[minor];
+	hw = &priv->hw;
+	
+	/* check offset provided by user */
+	if(*offset>=(HERMES_AUX_PAGES*HERMES_AUX_PAGESIZE))
+		return 0;
+	if((*offset+count)>(HERMES_AUX_PAGES*HERMES_AUX_PAGESIZE))
+		count=(HERMES_AUX_PAGES*HERMES_AUX_PAGESIZE)-(*offset);
+	if(count<=0)
+		return 0;
+	
+	res = orinoco_lock(priv, &flags); /* ##### LOCK ##### */
+	if(res)
+		return res;
+	
+	/* check if AUX port enabled / device ok */
+	if(!hermes_aux_enabled(hw)) {
+		res= -ENODEV;
+		goto out;
+	}
+	
+	/* tell the card the offset we want to read from */
+	hermes_write_regn(hw, AUXPAGE, *offset/HERMES_AUX_PAGESIZE);
+	hermes_write_regn(hw, AUXOFFSET,(*offset%HERMES_AUX_PAGESIZE)&0x7E);
+	
+	/* odd offset - gotta do a trick here since the card gives us 16bit blocks */
+	if((*offset)&1) {
+		pagebuf[0]=__le16_to_cpu(hermes_read_regn(hw,AUXDATA)); /* read 16 bit, but */
+#ifdef __LITTLE_ENDIAN
+		pagebuf[0]>>=8;
+#else
+		pagebuf[0]<<=8; /* copy only last byte to user */
+#endif
+		
+		if(copy_to_user(pb++,pagebuf,1)) {
+			res= -EFAULT;
+			goto out;
+		}
+		count--;
+	}
+	
+	/* read until <2 byte left */
+	while(count>1) {
+		if(count>=HERMES_AUX_PAGESIZE) /* normal block - we can read maximum block/page-size */
+			cnt=HERMES_AUX_PAGESIZE;
+		else
+			cnt=count&0x7E; /* last block - take what's left */
+		
+		for(cnt2=0;cnt2<(cnt>>1);cnt2++)
+			pagebuf[cnt2]=__le16_to_cpu(hermes_read_regn(hw, AUXDATA));
+		if(copy_to_user(pb,pagebuf,cnt)) {
+			res= -EFAULT;
+			goto out;
+		}
+		count-=cnt;
+		pb+=cnt;
+	}
+	
+	/* odd size - gotta do a trick here since the card gives us 16bit blocks */
+	if(count) {
+		pagebuf[0]=__le16_to_cpu(hermes_read_regn(hw, AUXDATA)); /* read 16 bit, but */
+		
+		if(copy_to_user(pb++,pagebuf,1)) { /* give the user only the first byte */
+			res= -EFAULT;
+			goto out;
+		}
+	}
+	
+	/* AUX port still enabled? - we got foobar-data if not -> tell it to the user */
+	if(!hermes_aux_enabled(hw)) {
+		res= -EIO;
+		goto out;
+	}
+	
+	/* increment offset by amount of bytes read */
+	*offset+=(pb-buf);
+	res=pb-buf;
+	
+out:                     /* error occured during writing */
+	
+	orinoco_unlock(priv, &flags); /* ##### UNLOCK ##### */	
+	
+	return res;
+}
+
+static ssize_t orinoco_mem_write (struct file *file, const char *buf, size_t count, loff_t *offset) {
+	struct orinoco_private *priv;
+	hermes_t *hw;
+	unsigned long flags;
+	u16 pagebuf[HERMES_AUX_PAGESIZE>>1];
+	const char *pb=buf;
+	int cnt,cnt2,res=0;
+	int minor;
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	if (orinoco_dev_priv[minor] == 0)
+		return -ENOTTY;
+
+	priv = (struct orinoco_private *)orinoco_dev_priv[minor];
+	hw = &priv->hw;
+		
+	/* check offset provided by user */
+	if(*offset>=(HERMES_AUX_PAGES*HERMES_AUX_PAGESIZE))
+		return 0;
+	if((*offset+count)>(HERMES_AUX_PAGES*HERMES_AUX_PAGESIZE))
+		count=(HERMES_AUX_PAGES*HERMES_AUX_PAGESIZE)-(*offset);
+	if(count<=0)
+		return 0;
+	
+	res = orinoco_lock(priv, &flags); /* ##### LOCK ##### */
+	if(res)
+		return res;
+	
+	if((priv->dl_pid) && (priv->dl_pid != current->pid)) {
+		res= -EBUSY;
+		goto out;
+	}
+	
+	/* AUX port enabled? */
+	if(!hermes_aux_enabled(hw)) {
+		res= -ENODEV;
+		goto out;
+	}
+	
+	/* tell the card the offset we wanna write to */
+	hermes_write_regn(hw, AUXPAGE, *offset/HERMES_AUX_PAGESIZE);
+	hermes_write_regn(hw, AUXOFFSET, (*offset%HERMES_AUX_PAGESIZE)&0x7E);
+	
+	/* odd offset? gotta trick here since talking with card is done in 16bit */
+	if((*offset)&1) {
+		
+		if(copy_from_user(pagebuf+1,pb++,1)) { /* get one byte from user */
+			res= -EFAULT;
+			goto out; /* error - we gotta do spin(un)lock and decrement the write counter before return */
+		}
+		
+		pagebuf[0]=__le16_to_cpu(hermes_read_regn(hw, AUXDATA)); /* get 16 bit from card */
+#ifdef __LITTLE_ENDIAN
+		pagebuf[0]&=0x00FF;
+		pagebuf[0]|=pagebuf[1]<<8;
+#else
+		pagebuf[0]&=0xFF00;  /* throw the last byte away and */
+		pagebuf[0]|=pagebuf[1]>>8; /* insert the byte from the user instead */
+#endif
+		
+		/* seek back to last shortword */
+		hermes_write_regn(hw, AUXPAGE, *offset/HERMES_AUX_PAGESIZE);
+		hermes_write_regn(hw, AUXOFFSET, (*offset%HERMES_AUX_PAGESIZE)&0x7E);
+		
+		hermes_write_regn(hw, AUXDATA, __cpu_to_le16(pagebuf[0])); /* write the 16 bit back to the card */
+		count--;
+	}
+	
+	/* read until <2 byte left */
+	while(count>1) {
+		if(count>=HERMES_AUX_PAGESIZE) /* normal block - write maximum block/pagesize */
+			cnt=HERMES_AUX_PAGESIZE;
+		else
+			cnt=count&0x7E; /* last block - write what's left */
+		
+		if(copy_from_user(pagebuf,pb,cnt)) {
+			res= -EFAULT;
+			goto out;
+		}
+
+		for(cnt2=0;cnt2<(cnt>>1);cnt2++)
+			hermes_write_regn(hw, AUXDATA,__cpu_to_le16(pagebuf[cnt2]));
+		count-=cnt;
+		pb+=cnt;
+	}
+	
+	/* odd size - gotta do a trick here since the card takes 16bit */
+	if(count) {
+		
+		if(copy_from_user(pagebuf+1,pb++,1)) {
+			res= -EFAULT;
+			goto out;
+		}
+		
+		pagebuf[0]=__le16_to_cpu(hermes_read_regn(hw, AUXDATA)); /* 16 bit from card */
+#ifdef __LITTLE_ENDIAN
+		pagebuf[0]&=0xFF00; /* throw 1st byte away and */
+		pagebuf[0]|=(pagebuf[1]&0x00FF); /* insert the last from the user */
+#else
+		pagebuf[0]&=0x00FF; /* throw 1st byte away and */
+		pagebuf[0]|=(pagebuf[1]&0xFF00); /* insert the last from the user */
+#endif
+		
+		/* seek back to last shortword */
+		hermes_write_regn(hw, AUXPAGE, (*offset+pb-buf)/HERMES_AUX_PAGESIZE);
+		hermes_write_regn(hw, AUXOFFSET, ((*offset+pb-buf)%HERMES_AUX_PAGESIZE)&0x7E);
+
+		hermes_write_regn(hw, AUXDATA, __cpu_to_le16(pagebuf[0]));
+	}
+	
+	/* AUX port still enabled? - we got foobar-data if not -> tell it to the user */
+	if(!hermes_aux_enabled(hw)) {
+		res= -EIO;
+		goto out;
+	}
+	
+	/* increment offset by amount of bytes read */
+	*offset+=(pb-buf);
+	res=pb-buf;
+	
+out:                     /* error occured during writing */
+	
+	orinoco_unlock(priv, &flags); /* ##### UNLOCK ##### */
+	
+	return res;
+}
+
+static loff_t orinoco_mem_llseek (struct file *filp, loff_t off, int whence) {
+	loff_t newpos;
+	
+	switch(whence) {
+		case 0: /* SEEK_SET */
+			newpos=off;
+		break;
+		
+		case 1: /* SEEK_CUR */
+			newpos=filp->f_pos + off;
+		break;
+		
+		case 2: /* SEEK_END */
+			newpos=(HERMES_AUX_PAGESIZE*HERMES_AUX_PAGES) + off;
+		break;
+		
+		default:
+			return -EINVAL;
+	}
+	if((newpos<0) || (newpos>(HERMES_AUX_PAGESIZE*HERMES_AUX_PAGES)))
+		return -EINVAL;
+	filp->f_pos=newpos;
+	return newpos;
+}
+
+/* end of mem_dev stuff */
+
+int orinoco_action(struct orinoco_private *priv, int action) {
+	int port;
+	int res=0;
+	unsigned long flags;
+	
+	if((action&ORINOCO_ACTION_MASK) == ORINOCO_REGISTER) {
+		/* register primary ndev */
+		priv->ndev->name[0] = '\0';
+		res = register_netdev(priv->ndev);
+		if(res)
+			printk(KERN_ERR "orinoco: register_netdev() failed: %d\n",res);
+	}
+	
+	else if((action&ORINOCO_ACTION_MASK) == ORINOCO_UNREGISTER) {
+		/* unregister primary ndev */
+		unregister_netdev(priv->ndev);
+		
+		/* unregister WDS ndevs */
+		for(port=0;port<WDS_PORTS;port++) {
+			if(priv->wdslink[port].dev.name[0]) {
+				unregister_netdev(&(priv->wdslink[port].dev));
+				priv->wdslink[port].dev.name[0]=0;
+			}
+		}
+	}
+	
+	else if((action&ORINOCO_ACTION_MASK) == ORINOCO_ATTACH) {
+		
+		if(priv->reset_active)
+			return 0;
+		
+		spin_lock_irqsave(&priv->lock, flags);
+		priv->hw_unavailable=0;
+		/* attach primary ndev */
+		netif_device_attach(priv->ndev);
+		
+		if(priv->open) {
+			res = __orinoco_up(priv->ndev);
+			if(res) {
+				printk(KERN_ERR "orinoco: Error %d upping device %s (primary) on ORINOCO_ATTACH\n",
+				       res, priv->ndev->name);
+				goto out;
+			}
+		}
+		
+		/* attach WDS ndevs */
+		for(port=0;port<WDS_PORTS;port++) {
+			if(priv->wdslink[port].dev.name[0]) {
+				netif_device_attach(&(priv->wdslink[port].dev));
+				if(priv->wdslink[port].info&WDS_INFO_OPEN) {
+					res = __orinoco_up(&(priv->wdslink[port].dev));
+					if(res) {
+						printk(KERN_ERR "orinoco: Error %d upping device %s (WDS %d) on ORINOCO_ATTACH\n",
+						   res, priv->ndev->name,port+1);
+						/* TODO: what to do if res? */
+					}
+				}
+			}
+		}
+		out:
+		spin_unlock_irqrestore(&priv->lock, flags);
+	}
+	
+	else if((action&ORINOCO_ACTION_MASK) == ORINOCO_DETACH) {
+		if((priv->hw_unavailable) && (!(action&ORINOCO_REMOVED))) {
+			printk(KERN_ERR "%s: hw_unavailable on ORINOCO_DETACH\n", priv->ndev->name);
+			return -EBUSY;
+		}
+		spin_lock_irqsave(&priv->lock, flags);
+		if((priv->open) && (!(action&ORINOCO_REMOVED))) {
+			res = __orinoco_down(priv->ndev);
+			if(res)
+				printk(KERN_ERR "orinoco: Error %d downing device %s (primary) on ORINOCO_ATTACH\n",
+				       res, priv->ndev->name);
+		}
+		/* detach primary ndev */
+		netif_device_detach(priv->ndev);
+		
+		/* detach WDS ndevs */
+		for(port=0;port<WDS_PORTS;port++) {
+			if(priv->wdslink[port].dev.name[0]) {
+				netif_device_detach(&(priv->wdslink[port].dev));
+				if((!(action&ORINOCO_REMOVED)) && (priv->wdslink[port].info&WDS_INFO_OPEN)) {
+					res = __orinoco_down(&(priv->wdslink[port].dev));
+					if(res)
+						printk(KERN_ERR "orinoco: Error %d downing device %s (WDS %d) on ORINOCO_ATTACH\n",
+						   res, priv->ndev->name, port+1);
+				}
+			}
+		}
+		priv->hw_unavailable=1;
+		spin_unlock_irqrestore(&priv->lock, flags);
+	}
+	
+	return res;
+}
+
 /********************************************************************/
 /* Module initialization                                            */
 /********************************************************************/
@@ -4188,23 +5702,37 @@
 
 EXPORT_SYMBOL(__orinoco_up);
 EXPORT_SYMBOL(__orinoco_down);
-EXPORT_SYMBOL(orinoco_stop);
 EXPORT_SYMBOL(orinoco_reinit_firmware);
 
 EXPORT_SYMBOL(orinoco_interrupt);
 
-/* Can't be declared "const" or the whole __initdata section will
- * become const */
-static char version[] __initdata = "orinoco.c 0.13e (David Gibson <hermes@gibson.dropbear.id.au> and others)";
+/* mem_dev stuff */
+EXPORT_SYMBOL(orinoco_mem_dev_init);
+EXPORT_SYMBOL(orinoco_mem_dev_cleanup);
+
+EXPORT_SYMBOL(orinoco_action);
+
+/* Can't be declared "const" or the whole __initdata section will become const */
+static char version[] __initdata = "orinoco.c 0.13c-nodevfs (David Gibson <hermes@gibson.dropbear.id.au> and others)";
+
+static int __init init_orinoco(void) {
+	int ret;
 
-static int __init init_orinoco(void)
-{
 	printk(KERN_DEBUG "%s\n", version);
+
+	ret = register_chrdev(ORINOCO_MAJOR,ORINOCO_DEVNAME,&orinoco_mem_fops);
+	if (ret < 0)
+		printk ("orinoco: failed to register memory character "
+			"device at major %d\n", ORINOCO_MAJOR);
+	else
+		printk ("orinoco: registered memory character device at "
+			"major %d\n", ORINOCO_MAJOR);
+	
 	return 0;
 }
 
-static void __exit exit_orinoco(void)
-{
+static void __exit exit_orinoco(void) {
+	unregister_chrdev(ORINOCO_MAJOR, ORINOCO_DEVNAME);
 }
 
 module_init(init_orinoco);
diff -Nru pcmcia-cs-3.2.8.orig/wireless/orinoco.h pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco.h
--- pcmcia-cs-3.2.8.orig/wireless/orinoco.h	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco.h	2006-03-18 16:27:20.000000000 +0100
@@ -12,6 +12,10 @@
 #include <linux/netdevice.h>
 #include <linux/wireless.h>
 #include <linux/version.h>
+
+/* for mem_dev */
+#include <linux/devfs_fs_kernel.h>
+
 #include "hermes.h"
 
 /* Workqueue / task queue backwards compatibility stuff */
@@ -25,15 +29,6 @@
 #define schedule_work schedule_task
 #endif
 
-/* Interrupt handler backwards compatibility stuff */
-#ifndef IRQ_NONE
-
-#define IRQ_NONE
-#define IRQ_HANDLED
-typedef void irqreturn_t;
-
-#endif
-
 /* To enable debug messages */
 //#define ORINOCO_DEBUG		3
 
@@ -45,6 +40,29 @@
 #define ORINOCO_MAX_KEY_SIZE	14
 #define ORINOCO_MAX_KEYS	4
 
+#define ORINOCO_DUMMY_FID	0xFFFF
+#define ORINOCO_TXFIDS		4
+
+#define ORINOCO_PREPARE_RAMDL	1
+#define	ORINOCO_FINISH_RAMDL	2
+
+#define ORINOCO_AP_ENABLED 	1
+#define	ORINOCO_AP_HIDDEN	2
+#define ORINOCO_AP_LEAVE	4
+
+struct wdslink { 
+        struct net_device dev;
+	u16 info;
+	u8 peer_addr[ETH_ALEN];
+	u16 rts_thres;
+	u16 bitratemode;
+        struct net_device_stats stats;
+	struct iw_statistics wstats;
+};      
+ 
+#define WDS_PORTS    	6
+#define WDS_INFO_OPEN	1
+
 struct orinoco_key {
 	u16 len;	/* always stored as little-endian */
 	char data[ORINOCO_MAX_KEY_SIZE];
@@ -56,18 +74,19 @@
 
 
 struct orinoco_private {
-	void *card;	/* Pointer to card dependent structure */
+	void *card;	/* Pointer to card dependant structure */
 	int (*hard_reset)(struct orinoco_private *);
 
 	/* Synchronisation stuff */
 	spinlock_t lock;
 	int hw_unavailable;
-	struct work_struct reset_work;
+	struct work_struct timeout_task;
 
 	/* driver state */
 	int open;
 	u16 last_linkstatus;
 	int connected;
+	int reset_active;
 
 	/* Net device stuff */
 	struct net_device *ndev;
@@ -76,8 +95,8 @@
 
 	/* Hardware control variables */
 	hermes_t hw;
-	u16 txfid;
-
+	u16 txfid[ORINOCO_TXFIDS];
+	int txfids;
 
 	/* Capabilities of the hardware/firmware */
 	int firmware_type;
@@ -92,7 +111,6 @@
 	int has_sensitivity;
 	int nicbuf_size;
 	u16 channel_mask;
-	int broken_disableport;
 
 	/* Configuration paramaters */
 	u32 iw_mode;
@@ -116,6 +134,15 @@
 	/* Configuration dependent variables */
 	int port_type, createibss;
 	int promiscuous, mc_count;
+	
+	/* mem_dev stuff */
+	devfs_handle_t mem_dev;
+	int mem_open;
+	pid_t dl_pid;
+
+	/* BSS master mode */
+	u32 ap_mode;
+	struct wdslink wdslink[WDS_PORTS];
 };
 
 #ifdef ORINOCO_DEBUG
@@ -132,9 +159,21 @@
 					   int (*hard_reset)(struct orinoco_private *));
 extern int __orinoco_up(struct net_device *dev);
 extern int __orinoco_down(struct net_device *dev);
-extern int orinoco_stop(struct net_device *dev);
-extern int orinoco_reinit_firmware(struct net_device *dev);
-extern irqreturn_t orinoco_interrupt(int irq, void * dev_id, struct pt_regs *regs);
+int orinoco_reinit_firmware(struct net_device *dev);
+
+extern void orinoco_interrupt(int irq, void * dev_id, struct pt_regs *regs);
+
+/* mem_dev stuff */
+extern int orinoco_mem_dev_init(struct orinoco_private *priv);
+extern void orinoco_mem_dev_cleanup(struct orinoco_private *priv);
+
+#define ORINOCO_REGISTER	0
+#define ORINOCO_UNREGISTER	1
+#define ORINOCO_ATTACH		2
+#define ORINOCO_DETACH		3
+#define ORINOCO_ACTION_MASK	7
+#define ORINOCO_REMOVED		0x80
+int orinoco_action(struct orinoco_private *priv, int action);
 
 /********************************************************************/
 /* Locking and synchronization functions                            */
@@ -163,4 +202,48 @@
 	spin_unlock_irqrestore(&priv->lock, *flags);
 }
 
+extern inline u16 orinoco_pop_txfid(struct orinoco_private *priv) {
+
+	if(!priv->txfids) 
+		return ORINOCO_DUMMY_FID;
+	else
+		return priv->txfid[--(priv->txfids)];
+}
+
+extern inline int orinoco_push_txfid(struct orinoco_private *priv, u16 fid) {
+
+	if(priv->txfids < ORINOCO_TXFIDS)
+		priv->txfid[(priv->txfids)++] = fid;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+extern inline int orinoco_lookup_port(struct net_device *dev) {
+	struct orinoco_private *priv = dev->priv;
+	int ret;
+	
+	if(dev == priv->ndev)
+		return 0;
+	for(ret=1;ret<=WDS_PORTS;ret++) {
+		if(dev == &(priv->wdslink[ret-1].dev))
+			return ret;
+	}
+	
+	return -EINVAL;
+}
+
+extern inline int orinoco_wds_active(struct orinoco_private *priv) {
+	int count;
+	int res=0;
+	
+	for(count=0;count<WDS_PORTS;count++) {
+		if((priv->wdslink[count].info&WDS_INFO_OPEN) && (priv->wdslink[count].dev.name[0]))
+			res++;
+	}
+	
+	return res;
+}
+
 #endif /* _ORINOCO_H */
diff -Nru pcmcia-cs-3.2.8.orig/wireless/orinoco_cs.c pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco_cs.c
--- pcmcia-cs-3.2.8.orig/wireless/orinoco_cs.c	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco_cs.c	2006-03-18 16:27:20.000000000 +0100
@@ -1,4 +1,4 @@
-/* orinoco_cs.c 0.13e	- (formerly known as dldwd_cs.c)
+/* orinoco_cs.c 0.13c	- (formerly known as dldwd_cs.c)
  *
  * A driver for "Hermes" chipset based PCMCIA wireless adaptors, such
  * as the Lucent WavelanIEEE/Orinoco cards and their OEM (Cabletron/
@@ -11,6 +11,10 @@
  */
 
 #include <linux/config.h>
+#ifdef  __IN_PCMCIA_PACKAGE__
+#include <pcmcia/k_compat.h>
+#endif /* __IN_PCMCIA_PACKAGE__ */
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -18,7 +22,11 @@
 #include <linux/ptrace.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/timer.h>
 #include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/system.h>
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
 #include <linux/etherdevice.h>
@@ -30,10 +38,7 @@
 #include <pcmcia/cistpl.h>
 #include <pcmcia/cisreg.h>
 #include <pcmcia/ds.h>
-
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/system.h>
+#include <pcmcia/bus_ops.h>
 
 #include "orinoco.h"
 
@@ -140,10 +145,8 @@
 /* PCMCIA stuff     						    */
 /********************************************************************/
 
-/* In 2.5 (as of 2.5.69 at least) there is a cs_error exported which
- * does this, but it's not in 2.4 so we do our own for now. */
 static void
-orinoco_cs_error(client_handle_t handle, int func, int ret)
+cs_error(client_handle_t handle, int func, int ret)
 {
 	error_info_t err = { func, ret };
 	CardServices(ReportError, handle, &err);
@@ -199,7 +202,6 @@
 	link->priv = dev;
 
 	/* Initialize the dev_link_t structure */
-	init_timer(&link->release);
 	link->release.function = &orinoco_cs_release;
 	link->release.data = (u_long) link;
 
@@ -238,7 +240,7 @@
 
 	ret = CardServices(RegisterClient, &link->handle, &client_reg);
 	if (ret != CS_SUCCESS) {
-		orinoco_cs_error(link->handle, RegisterClient, ret);
+		cs_error(link->handle, RegisterClient, ret);
 		orinoco_cs_detach(link);
 		return NULL;
 	}
@@ -267,12 +269,19 @@
 		return;
 	}
 
+	/*
+	   If the device is currently configured and active, we won't
+	   actually delete it yet.  Instead, it is marked so that when
+	   the release() function is called, that will trigger a proper
+	   detach().
+	 */
 	if (link->state & DEV_CONFIG) {
-		orinoco_cs_release((u_long)link);
-		if (link->state & DEV_CONFIG) {
-			link->state |= DEV_STALE_LINK;
-			return;
-		}
+#ifdef PCMCIA_DEBUG
+		printk(KERN_DEBUG "orinoco_cs: detach postponed, '%s' "
+		       "still locked\n", link->dev->dev_name);
+#endif
+		link->state |= DEV_STALE_LINK;
+		return;
 	}
 
 	/* Break the link with Card Services */
@@ -283,9 +292,11 @@
 	*linkp = link->next;
 	DEBUG(0, "orinoco_cs: detach: link=%p link->dev=%p\n", link, link->dev);
 	if (link->dev) {
-		DEBUG(0, "orinoco_cs: About to unregister net device %p\n",
-		      dev);
-		unregister_netdev(dev);
+		
+		/* unregister memory access device */
+		orinoco_mem_dev_cleanup(dev->priv);
+		
+		orinoco_action(dev->priv, ORINOCO_UNREGISTER);
 	}
 	kfree(dev);
 }				/* orinoco_cs_detach */
@@ -359,7 +370,7 @@
 	CS_CHECK(GetFirstTuple, handle, &tuple);
 	while (1) {
 		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
-		cistpl_cftable_entry_t dflt = { .index = 0 };
+		cistpl_cftable_entry_t dflt = { index: 0 };
 
 		CFG_CHECK(GetTupleData, handle, &tuple);
 		CFG_CHECK(ParseTuple, handle, &tuple, &parse);
@@ -487,13 +498,11 @@
 	SET_MODULE_OWNER(dev);
 	card->node.major = card->node.minor = 0;
 
-	/* register_netdev will give us an ethX name */
-	dev->name[0] = '\0';
-	/* Tell the stack we exist */
-	if (register_netdev(dev) != 0) {
-		printk(KERN_ERR "orinoco_cs: register_netdev() failed\n");
+	if(orinoco_action(priv,ORINOCO_REGISTER))
 		goto failed;
-	}
+	
+	/* register the memory access device */
+	orinoco_mem_dev_init(priv);
 
 	/* At this point, the dev_node_t structure(s) needs to be
 	 * initialized and arranged in a linked list at link->dev. */
@@ -523,7 +532,7 @@
 	return;
 
  cs_failed:
-	orinoco_cs_error(link->handle, last_fn, last_ret);
+	cs_error(link->handle, last_fn, last_ret);
 
  failed:
 	orinoco_cs_release((u_long) link);
@@ -540,13 +549,18 @@
 	dev_link_t *link = (dev_link_t *) arg;
 	struct net_device *dev = link->priv;
 	struct orinoco_private *priv = dev->priv;
-	unsigned long flags;
 
-	/* We're committed to taking the device away now, so mark the
-	 * hardware as unavailable */
-	spin_lock_irqsave(&priv->lock, flags);
-	priv->hw_unavailable++;
-	spin_unlock_irqrestore(&priv->lock, flags);
+	/*
+	   If the device is currently in use, we won't release until it
+	   is actually closed, because until then, we can't be sure that
+	   no one will try to access the device or its data structures.
+	 */
+	if (priv->open) {
+		DEBUG(0, "orinoco_cs: release postponed, '%s' still open\n",
+		      link->dev->dev_name);
+		link->state |= DEV_STALE_CONFIG;
+		return;
+	}
 
 	/* Don't bother checking to see if these succeed or not */
 	CardServices(ReleaseConfiguration, link->handle);
@@ -570,18 +584,14 @@
 	struct orinoco_private *priv = dev->priv;
 	struct orinoco_pccard *card = priv->card;
 	int err = 0;
-	unsigned long flags;
 
 	switch (event) {
 	case CS_EVENT_CARD_REMOVAL:
 		link->state &= ~DEV_PRESENT;
 		if (link->state & DEV_CONFIG) {
-			orinoco_lock(priv, &flags);
-
-			netif_device_detach(dev);
-			priv->hw_unavailable++;
+			orinoco_action(priv, ORINOCO_DETACH | ORINOCO_REMOVED);
 
-			orinoco_unlock(priv, &flags);
+			mod_timer(&link->release, jiffies + HZ / 20);
 		}
 		break;
 
@@ -600,22 +610,10 @@
                            a better way, short of rewriting the PCMCIA
                            layer to not suck :-( */
 			if (! test_bit(0, &card->hard_reset_in_progress)) {
-				spin_lock_irqsave(&priv->lock, flags);
-
-				err = __orinoco_down(dev);
-				if (err)
-					printk(KERN_WARNING "%s: %s: Error %d downing interface\n",
-					       dev->name,
-					       event == CS_EVENT_PM_SUSPEND ? "SUSPEND" : "RESET_PHYSICAL",
-					       err);
-				
-				netif_device_detach(dev);
-				priv->hw_unavailable++;
-
-				spin_unlock_irqrestore(&priv->lock, flags);
+				orinoco_action(priv, ORINOCO_DETACH);
 			}
-
 			CardServices(ReleaseConfiguration, link->handle);
+
 		}
 		break;
 
@@ -629,6 +627,10 @@
 			CardServices(RequestConfiguration, link->handle,
 				     &link->conf);
 
+			/* If we're only getting these events because
+                           of the ResetCard in the hard reset, we
+                           don't need to do anything - orinoco_reset()
+                           will handle reinitialization. */
 			if (! test_bit(0, &card->hard_reset_in_progress)) {
 				err = orinoco_reinit_firmware(dev);
 				if (err) {
@@ -637,20 +639,7 @@
 					break;
 				}
 				
-				spin_lock_irqsave(&priv->lock, flags);
-				
-				netif_device_attach(dev);
-				priv->hw_unavailable--;
-				
-				if (priv->open && ! priv->hw_unavailable) {
-					err = __orinoco_up(dev);
-					if (err)
-						printk(KERN_ERR "%s: Error %d restarting card\n",
-						       dev->name, err);
-					
-				}
-
-				spin_unlock_irqrestore(&priv->lock, flags);
+				orinoco_action(priv, ORINOCO_ATTACH);
 			}
 		}
 		break;
@@ -665,7 +654,7 @@
 
 /* Can't be declared "const" or the whole __initdata section will
  * become const */
-static char version[] __initdata = "orinoco_cs.c 0.13e (David Gibson <hermes@gibson.dropbear.id.au> and others)";
+static char version[] __initdata = "orinoco_cs.c 0.13c (David Gibson <hermes@gibson.dropbear.id.au> and others)";
 
 static int __init
 init_orinoco_cs(void)
@@ -678,7 +667,7 @@
 	if (serv.Revision != CS_RELEASE_CODE) {
 		printk(KERN_NOTICE "orinoco_cs: Card Services release "
 		       "does not match!\n");
-		return -EINVAL;
+		return -1;
 	}
 
 	register_pccard_driver(&dev_info, &orinoco_cs_attach, &orinoco_cs_detach);
@@ -694,6 +683,7 @@
 	if (dev_list)
 		DEBUG(0, "orinoco_cs: Removing leftover devices.\n");
 	while (dev_list != NULL) {
+		del_timer(&dev_list->release);
 		if (dev_list->state & DEV_CONFIG)
 			orinoco_cs_release((u_long) dev_list);
 		orinoco_cs_detach(dev_list);
diff -Nru pcmcia-cs-3.2.8.orig/wireless/orinoco_pci.c pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco_pci.c
--- pcmcia-cs-3.2.8.orig/wireless/orinoco_pci.c	1970-01-01 01:00:00.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco_pci.c	2006-03-18 16:27:20.000000000 +0100
@@ -0,0 +1,373 @@
+/* orinoco_pci.c 0.13c
+ * 
+ * Driver for Prism II devices that have a direct PCI interface
+ * (i.e., not in a Pcmcia or PLX bridge)
+ *
+ * Specifically here we're talking about the Linksys WMP11
+ *
+ * Some of this code is borrowed from orinoco_plx.c
+ *	Copyright (C) 2001 Daniel Barlow <dan@telent.net>
+ * Some of this code is "inspired" by linux-wlan-ng-0.1.10, but nothing
+ * has been copied from it. linux-wlan-ng-0.1.10 is originally :
+ *	Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+ * This file originally written by:
+ *	Copyright (C) 2001 Jean Tourrilhes <jt@hpl.hp.com>
+ * And is now maintained by:
+ *	Copyright (C) 2002 David Gibson, IBM Corporation <herme@gibson.dropbear.id.au>
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License
+ * at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the MPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the MPL or the GPL.
+ */
+
+/*
+ * Theory of operation...
+ * -------------------
+ * Maybe you had a look in orinoco_plx. Well, this is totally different...
+ *
+ * The card contains only one PCI region, which contains all the usual
+ * hermes registers.
+ *
+ * The driver will memory map this region in normal memory. Because
+ * the hermes registers are mapped in normal memory and not in ISA I/O
+ * post space, we can't use the usual inw/outw macros and we need to
+ * use readw/writew.
+ * This slight difference force us to compile our own version of
+ * hermes.c with the register access macro changed. That's a bit
+ * hackish but works fine.
+ *
+ * Note that the PCI region is pretty big (4K). That's much more than
+ * the usual set of hermes register (0x0 -> 0x3E). I've got a strong
+ * suspicion that the whole memory space of the adapter is in fact in
+ * this region. Accessing directly the adapter memory instead of going
+ * through the usual register would speed up significantely the
+ * operations...
+ *
+ * Finally, the card looks like this :
+-----------------------
+  Bus  0, device  14, function  0:
+    Network controller: PCI device 1260:3873 (Harris Semiconductor) (rev 1).
+      IRQ 11.
+      Master Capable.  Latency=248.  
+      Prefetchable 32 bit memory at 0xffbcc000 [0xffbccfff].
+-----------------------
+00:0e.0 Network controller: Harris Semiconductor: Unknown device 3873 (rev 01)
+        Subsystem: Unknown device 1737:3874
+        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B-
+        Status: Cap+ 66Mhz- UDF- FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
+        Latency: 248 set, cache line size 08
+        Interrupt: pin A routed to IRQ 11
+        Region 0: Memory at ffbcc000 (32-bit, prefetchable) [size=4K]
+        Capabilities: [dc] Power Management version 2
+                Flags: PMEClk- AuxPwr- DSI- D1+ D2+ PME+
+                Status: D0 PME-Enable- DSel=0 DScale=0 PME-
+-----------------------
+ *
+ * That's all..
+ *
+ * Jean II
+ */
+
+#include <linux/config.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/wireless.h>
+#include <linux/fcntl.h>
+
+#include "hermes.h"
+#include "orinoco.h"
+
+/* All the magic there is from wlan-ng */
+/* Magic offset of the reset register of the PCI card */
+#define HERMES_PCI_COR		(0x26)
+/* Magic bitmask to reset the card */
+#define HERMES_PCI_COR_MASK	(0x0080)
+/* Magic timeouts for doing the reset.
+ * Those times are straight from wlan-ng, and it is claimed that they
+ * are necessary. Alan will kill me. Take your time and grab a coffee. */
+#define HERMES_PCI_COR_ONT	(250)		/* ms */
+#define HERMES_PCI_COR_OFFT	(500)		/* ms */
+#define HERMES_PCI_COR_BUSYT	(500)		/* ms */
+
+/*
+ * Do a soft reset of the PCI card using the Configuration Option Register
+ * We need this to get going...
+ * This is the part of the code that is strongly inspired from wlan-ng
+ *
+ * Note : This code is done with irq enabled. This mean that many
+ * interrupts will occur while we are there. This is why we use the
+ * jiffies to regulate time instead of a straight mdelay(). Usually we
+ * need only around 245 iteration of the loop to do 250 ms delay.
+ *
+ * Note bis : Don't try to access HERMES_CMD during the reset phase.
+ * It just won't work !
+ */
+static int
+orinoco_pci_cor_reset(struct orinoco_private *priv)
+{
+	hermes_t *hw = &priv->hw;
+	unsigned long	timeout;
+	u16	reg;
+
+	/* Assert the reset until the card notice */
+	hermes_write_regn(hw, PCI_COR, HERMES_PCI_COR_MASK);
+	printk(KERN_NOTICE "Reset done");
+	timeout = jiffies + (HERMES_PCI_COR_ONT * HZ / 1000);
+	while(time_before(jiffies, timeout)) {
+		printk(".");
+		mdelay(1);
+	}
+	printk(";\n");
+	//mdelay(HERMES_PCI_COR_ONT);
+
+	/* Give time for the card to recover from this hard effort */
+	hermes_write_regn(hw, PCI_COR, 0x0000);
+	printk(KERN_NOTICE "Clear Reset");
+	timeout = jiffies + (HERMES_PCI_COR_OFFT * HZ / 1000);
+	while(time_before(jiffies, timeout)) {
+		printk(".");
+		mdelay(1);
+	}
+	printk(";\n");
+	//mdelay(HERMES_PCI_COR_OFFT);
+
+	/* The card is ready when it's no longer busy */
+	timeout = jiffies + (HERMES_PCI_COR_BUSYT * HZ / 1000);
+	reg = hermes_read_regn(hw, CMD);
+	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
+		mdelay(1);
+		reg = hermes_read_regn(hw, CMD);
+	}
+	/* Did we timeout ? */
+	if(time_after_eq(jiffies, timeout)) {
+		printk(KERN_ERR "orinoco_pci: Busy timeout\n");
+		return -ETIMEDOUT;
+	}
+	printk(KERN_NOTICE "pci_cor : reg = 0x%X - %lX - %lX\n", reg, timeout, jiffies);
+
+	return 0;
+}
+
+/*
+ * Initialise a card. Mostly similar to PLX code.
+ */
+static int orinoco_pci_init_one(struct pci_dev *pdev,
+				const struct pci_device_id *ent)
+{
+	int err = 0;
+	unsigned long pci_iorange;
+	u16 *pci_ioaddr = NULL;
+	unsigned long pci_iolen;
+	struct orinoco_private *priv = NULL;
+	struct net_device *dev = NULL;
+	int netdev_registered = 0;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		return -EIO;
+
+	/* Resource 0 is mapped to the hermes registers */
+	pci_iorange = pci_resource_start(pdev, 0);
+	pci_iolen = pci_resource_len(pdev, 0);
+	pci_ioaddr = ioremap(pci_iorange, pci_iolen);
+	if (! pci_iorange)
+		goto fail;
+
+	/* Usual setup of structures */
+	dev = alloc_orinocodev(0, NULL);
+	if (! dev) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	priv = dev->priv;
+
+	dev->base_addr = (int) pci_ioaddr;
+        dev->mem_start = (unsigned long) pci_iorange;
+        dev->mem_end = ((unsigned long) pci_iorange) + pci_iolen - 1;
+
+	SET_MODULE_OWNER(dev);
+
+	printk(KERN_DEBUG
+	       "Detected Orinoco/Prism2 PCI device at %s, mem:0x%lX to 0x%lX -> 0x%p, irq:%d\n",
+	       pdev->slot_name, dev->mem_start, dev->mem_end, pci_ioaddr, pdev->irq);
+
+	hermes_struct_init(&(priv->hw), dev->base_addr, HERMES_MEM, HERMES_32BIT_REGSPACING);
+	pci_set_drvdata(pdev, dev);
+
+	err = request_irq(pdev->irq, orinoco_interrupt, SA_SHIRQ, dev->name, dev);
+	if (err) {
+		printk(KERN_ERR "orinoco_pci: Error allocating IRQ %d.\n", pdev->irq);
+		err = -EBUSY;
+		goto fail;
+	}
+	dev->irq = pdev->irq;
+	/* Perform a COR reset to start the card */
+	if(orinoco_pci_cor_reset(priv) != 0) {
+		printk(KERN_ERR "%s: Failed to start the card\n", dev->name);
+		err = -ETIMEDOUT;
+		goto fail;
+	}
+
+	/* Override the normal firmware detection - the Prism 2.5 PCI
+	 * cards look like Lucent firmware but are actually Intersil */
+	priv->firmware_type = FIRMWARE_TYPE_INTERSIL;
+
+	if (orinoco_action(priv, ORINOCO_REGISTER)) 
+		goto fail;
+	netdev_registered = 1;
+
+	/* register the memory access device */
+	orinoco_mem_dev_init(priv);
+	
+    return 0;               /* succeeded */
+ fail:
+	if (dev) {
+		if (netdev_registered)
+			orinoco_action(priv, ORINOCO_UNREGISTER);
+
+		if (dev->irq)
+			free_irq(dev->irq, priv);
+
+		kfree(dev);
+	}
+
+	if (pci_ioaddr)
+		iounmap(pci_ioaddr);
+
+	return err;
+}
+
+static void __devexit orinoco_pci_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct orinoco_private *priv = dev->priv;
+
+	if (! dev)
+		BUG();
+
+	/* unregister memory access device */
+	orinoco_mem_dev_cleanup(priv);
+	
+	orinoco_action(priv, ORINOCO_UNREGISTER);
+
+        if (dev->irq)
+		free_irq(dev->irq, priv);
+
+	if (priv->hw.iobase)
+		iounmap((unsigned char *) priv->hw.iobase);
+
+	pci_set_drvdata(pdev, NULL);
+	kfree(dev);
+
+	pci_disable_device(pdev);
+}
+
+static int orinoco_pci_suspend(struct pci_dev *pdev, u32 state)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct orinoco_private *priv = dev->priv;
+	
+	printk(KERN_DEBUG "%s: Orinoco-PCI entering sleep mode (state=%d)\n",
+	       dev->name, state);
+
+	orinoco_action(priv, ORINOCO_DETACH);
+
+	return 0;
+}
+
+static int orinoco_pci_resume(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct orinoco_private *priv = dev->priv;
+	int err;
+
+	printk(KERN_DEBUG "%s: Orinoco-PCI waking up\n", dev->name);
+
+	err = orinoco_reinit_firmware(dev);
+	if (err) {
+		printk(KERN_ERR "%s: Error %d re-initializing firmware on orinoco_pci_resume()\n",
+		       dev->name, err);
+		return err;
+	}
+
+	orinoco_action(priv, ORINOCO_ATTACH);
+
+	return 0;
+}
+
+static struct pci_device_id orinoco_pci_pci_id_table[] __devinitdata = {
+	{0x1260, 0x3873, PCI_ANY_ID, PCI_ANY_ID,},
+	{0,},
+};
+
+MODULE_DEVICE_TABLE(pci, orinoco_pci_pci_id_table);
+
+static struct pci_driver orinoco_pci_driver = {
+	.name		= "orinoco_pci",
+	.id_table	= orinoco_pci_pci_id_table,
+	.probe		= orinoco_pci_init_one,
+	.remove		= __devexit_p(orinoco_pci_remove_one),
+	.suspend	= orinoco_pci_suspend,
+	.resume		= orinoco_pci_resume,
+};
+
+static char version[] __initdata = "orinoco_pci.c 0.13c (David Gibson <hermes@gibson.dropbear.id.au> & Jean Tourrilhes <jt@hpl.hp.com>)";
+MODULE_AUTHOR("David Gibson <hermes@gibson.dropbear.id.au>");
+MODULE_DESCRIPTION("Driver for wireless LAN cards using direct PCI interface");
+MODULE_LICENSE("Dual MPL/GPL");
+
+static int __init orinoco_pci_init(void)
+{
+	printk(KERN_DEBUG "%s\n", version);
+	return pci_module_init(&orinoco_pci_driver);
+}
+
+extern void __exit orinoco_pci_exit(void)
+{
+	pci_unregister_driver(&orinoco_pci_driver);
+}
+
+module_init(orinoco_pci_init);
+module_exit(orinoco_pci_exit);
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ * End:
+ */
diff -Nru pcmcia-cs-3.2.8.orig/wireless/orinoco_plx.c pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco_plx.c
--- pcmcia-cs-3.2.8.orig/wireless/orinoco_plx.c	2006-03-18 15:53:40.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco_plx.c	2006-03-18 16:27:20.000000000 +0100
@@ -1,4 +1,4 @@
-/* orinoco_plx.c 0.13e
+/* orinoco_plx.c 0.13c
  * 
  * Driver for Prism II devices which would usually be driven by orinoco_cs,
  * but are connected to the PCI bus by a PLX9052. 
@@ -145,120 +145,6 @@
 	0x0001, 0x0003, 0x0000, 0x0000, 0x00ff, 0x0017, 0x0004, 0x0067
 };
 
-/****************************************************************************
- * Linux 2.2.x compatibility hackery
- ****************************************************************************/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-
-#define PCI_ANY_ID (~0)
-struct pci_device_id {
-	unsigned int vendor, device;		/* Vendor and device ID or PCI_ANY_ID */
-	unsigned int subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
-	unsigned int class, class_mask;		/* (class,subclass,prog-if) triplet */
-	unsigned long driver_data;		/* Data private to the driver */
-};
-
-/*
- * linux-2.2 struct pci_dev does not have a private drvdata pointer so we need to keep
- * track of the various struct pointers manually.
- */
-#define ORINOCO_PLX_MAX_DEVS	4
-#define ORINOCO_PLX_DEVS_FULL	(orinoco_plx_num_devs >= ORINOCO_PLX_MAX_DEVS)
-
-static int orinoco_plx_num_devs;
-static struct orinoco_plx_devs_t {
-	struct pci_dev *pdev;
-	void *drvdata;
-} orinoco_plx_devs[ORINOCO_PLX_MAX_DEVS];
-
-static void orinoco_plx_pci_set_drvdata(struct pci_dev *pdev,
-					       void *drvdata) {
-	orinoco_plx_devs[orinoco_plx_num_devs].pdev = pdev;
-	orinoco_plx_devs[orinoco_plx_num_devs].drvdata = drvdata;
-}
-static void *orinoco_plx_pci_get_drvdata(struct pci_dev *pdev) {
-	int i;
-	for (i=0; i<ORINOCO_PLX_MAX_DEVS; i++)
-		if (orinoco_plx_devs[i].pdev == pdev)
-			return orinoco_plx_devs[i].drvdata;
-	return NULL;
-}
-#define pci_set_drvdata orinoco_plx_pci_set_drvdata
-#define pci_get_drvdata orinoco_plx_pci_get_drvdata
-
-/* Our own simple pci_{en,dis}able_device() definitions */
-static int orinoco_plx_pci_enable_device(struct pci_dev *pdev) {
-	pci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
-	return 0;
-}
-static int orinoco_plx_pci_disable_device(struct pci_dev *pdev) {
-	pci_write_config_word(pdev, PCI_COMMAND, 0);
-	return 0;
-}
-#undef pci_enable_device	/* override pcmcia-cs compatibility version */
-#define pci_enable_device orinoco_plx_pci_enable_device
-#define pci_disable_device orinoco_plx_pci_disable_device
-
-/* linux-2.2 request_region() does not return a value. */
-static int orinoco_plx_request_region(unsigned long from, unsigned long extent, const char *name) {
-	request_region(from,extent,name);
-	return 1;
-}
-#define request_region orinoco_plx_request_region
-
-/* Not really needed for linux-2.2, but using it helps keep compatibility changes localized */
-struct pci_driver {
-	struct list_head node;
-	char *name;
-	const struct pci_device_id *id_table;					/* NULL if wants all devices */
-	int  (*probe)  (struct pci_dev *dev, const struct pci_device_id *id);	/* New device inserted */
-	void (*remove) (struct pci_dev *dev);					/* Device removed (NULL if not a hot-plug capable driver) */
-	int  (*save_state) (struct pci_dev *dev, u32 state);			/* Save Device Context */
-	int  (*suspend) (struct pci_dev *dev, u32 state);			/* Device suspended */
-	int  (*resume) (struct pci_dev *dev);					/* Device woken up */
-	int  (*enable_wake) (struct pci_dev *dev, u32 state, int enable);	/* Enable wake event */
-};
-
-/* Not available in linux-2.2 */
-#define MODULE_DEVICE_TABLE(a,b)
-
-/* Replacement PCI scanning routine */
-static int orinoco_plx_scan(struct pci_driver *drv)
-{
-	struct pci_dev *dev;
-	const struct pci_device_id *id;
-
-	memset( orinoco_plx_devs, 0, sizeof(orinoco_plx_devs) );
-	orinoco_plx_num_devs = 0;
-
-	for (id=drv->id_table; id->vendor && !ORINOCO_PLX_DEVS_FULL; id++) {
-		dev = NULL;
-		while ((dev = pci_find_device(id->vendor, id->device, dev))) {
-			if (drv->probe(dev, id) == 0) {
-				orinoco_plx_num_devs++;
-				if ( ORINOCO_PLX_DEVS_FULL )
-					break;
-			}
-		}
-	}
-
-	return (orinoco_plx_num_devs == 0) ? -ENODEV : 0;
-}
-#define pci_module_init orinoco_plx_scan
-
-/* Replacement PCI unregister routine */
-static void orinoco_plx_shutdown(struct pci_driver *drv)
-{
-	while( orinoco_plx_num_devs-- > 0 )
-		drv->remove(orinoco_plx_devs[orinoco_plx_num_devs].pdev);
-}
-#define pci_unregister_driver orinoco_plx_shutdown
-
-#endif
-/****************************************************************************
- * End Linux 2.2.x compatibility hackery
- ****************************************************************************/
-
 static int orinoco_plx_init_one(struct pci_dev *pdev,
 				const struct pci_device_id *ent)
 {
@@ -269,6 +155,7 @@
 	unsigned long pccard_ioaddr = 0;
 	unsigned long pccard_iolen = 0;
 	struct net_device *dev = NULL;
+	int netdev_registered = 0;
 	int i;
 
 	err = pci_enable_device(pdev);
@@ -313,7 +200,7 @@
 	addr = pci_resource_start(pdev, 1);
 	reg = 0;
 	reg = inl(addr+PLX_INTCSR);
-	if (reg & PLX_INTCSR_INTEN)
+	if(reg & PLX_INTCSR_INTEN)
 		printk(KERN_DEBUG "orinoco_plx: "
 		       "Local Interrupt already enabled\n");
 	else {
@@ -349,8 +236,8 @@
 	SET_MODULE_OWNER(dev);
 
 	printk(KERN_DEBUG
-	       "Detected Orinoco/Prism2 PLX device at irq:%d, io addr:0x%lx\n",
-	       pdev->irq, pccard_ioaddr);
+	       "Detected Orinoco/Prism2 PLX device at %s irq:%d, io addr:0x%lx\n",
+	       pdev->slot_name, pdev->irq, pccard_ioaddr);
 
 	hermes_struct_init(&(priv->hw), dev->base_addr,
 			HERMES_IO, HERMES_16BIT_REGSPACING);
@@ -364,25 +251,26 @@
 	}
 	dev->irq = pdev->irq;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-	/* register_netdev will give us an ethX name */
-	dev->name = "";
-#endif
-
-	err = register_netdev(dev);
-	if (err)
+	if(orinoco_action(priv, ORINOCO_REGISTER))
 		goto fail;
+	netdev_registered = 1;
 
+	/* register the memory access device */
+	orinoco_mem_dev_init(priv);
+	
 	return 0;		/* succeeded */
 
  fail:	
 	printk(KERN_DEBUG "orinoco_plx: init_one(), FAIL!\n");
 
-	if (dev) {
+	if (priv) {
+		if (netdev_registered)
+			orinoco_action(priv, ORINOCO_UNREGISTER);
+		
 		if (dev->irq)
-			free_irq(dev->irq, dev);
+			free_irq(dev->irq, priv);
 		
-		kfree(dev);
+		kfree(priv);
 	}
 
 	if (pccard_ioaddr)
@@ -399,14 +287,18 @@
 static void __devexit orinoco_plx_remove_one(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
+	struct orinoco_private *priv = dev->priv;
 
 	if (! dev)
 		BUG();
 
-	unregister_netdev(dev);
+	/* unregister memory access device */
+	orinoco_mem_dev_cleanup(priv);
+	
+	orinoco_action(priv, ORINOCO_UNREGISTER);
 		
 	if (dev->irq)
-		free_irq(dev->irq, dev);
+		free_irq(dev->irq, priv);
 		
 	pci_set_drvdata(pdev, NULL);
 
@@ -447,7 +339,7 @@
 	.resume		= 0,
 };
 
-static char version[] __initdata = "orinoco_plx.c 0.13e (Daniel Barlow <dan@telent.net>, David Gibson <hermes@gibson.dropbear.id.au>)";
+static char version[] __initdata = "orinoco_plx.c 0.13c (Daniel Barlow <dan@telent.net>, David Gibson <hermes@gibson.dropbear.id.au>)";
 MODULE_AUTHOR("Daniel Barlow <dan@telent.net>");
 MODULE_DESCRIPTION("Driver for wireless LAN cards using the PLX9052 PCI bridge");
 #ifdef MODULE_LICENSE
diff -Nru pcmcia-cs-3.2.8.orig/wireless/orinoco_tmd.c pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco_tmd.c
--- pcmcia-cs-3.2.8.orig/wireless/orinoco_tmd.c	1970-01-01 01:00:00.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/orinoco_tmd.c	2006-03-18 16:27:20.000000000 +0100
@@ -0,0 +1,246 @@
+/* orinoco_tmd.c 0.01
+ * 
+ * Driver for Prism II devices which would usually be driven by orinoco_cs,
+ * but are connected to the PCI bus by a TMD7160. 
+ *
+ * Copyright (C) 2003 Joerg Dorchain <joerg@dorchain.net>
+ * based heavily upon orinoco_plx.c Copyright (C) 2001 Daniel Barlow <dan@telent.net>
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License
+ * at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the MPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the MPL or the GPL.
+
+ * Caution: this is experimental and probably buggy.  For success and
+ * failure reports for different cards and adaptors, see
+ * orinoco_tmd_pci_id_table near the end of the file.  If you have a
+ * card we don't have the PCI id for, and looks like it should work,
+ * drop me mail with the id and "it works"/"it doesn't work".
+ *
+ * Note: if everything gets detected fine but it doesn't actually send
+ * or receive packets, your first port of call should probably be to   
+ * try newer firmware in the card.  Especially if you're doing Ad-Hoc
+ * modes
+ *
+ * The actual driving is done by orinoco.c, this is just resource
+ * allocation stuff.
+ *
+ * This driver is modeled after the orinoco_plx driver. The main
+ * difference is that the TMD chip has only IO port ranges and no
+ * memory space, i.e.  no access to the CIS. Compared to the PLX chip,
+ * the io range functionalities are exchanged.
+ *
+ * Pheecom sells cards with the TMD chip as "ASIC version"
+ */
+
+#include <linux/config.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/wireless.h>
+#include <linux/fcntl.h>
+
+#include <pcmcia/cisreg.h>
+
+#include "hermes.h"
+#include "orinoco.h"
+
+static char dev_info[] = "orinoco_tmd";
+
+#define COR_VALUE     (COR_LEVEL_REQ | COR_FUNC_ENA | COR_FUNC_ENA) /* Enable PC card with level triggered irqs and irq requests */
+
+
+static int orinoco_tmd_init_one(struct pci_dev *pdev,
+				const struct pci_device_id *ent)
+{
+	int err = 0;
+	u32 reg, addr;
+	struct orinoco_private *priv = NULL;
+	unsigned long pccard_ioaddr = 0;
+	unsigned long pccard_iolen = 0;
+	struct net_device *dev = NULL;
+	int netdev_registered = 0;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		return -EIO;
+
+	printk(KERN_DEBUG "TMD setup\n");
+	pccard_ioaddr = pci_resource_start(pdev, 2);
+	pccard_iolen = pci_resource_len(pdev, 2);
+	if (! request_region(pccard_ioaddr, pccard_iolen, dev_info)) {
+		printk(KERN_ERR "orinoco_tmd: I/O resource at 0x%lx len 0x%lx busy\n",
+			pccard_ioaddr, pccard_iolen);
+		pccard_ioaddr = 0;
+		err = -EBUSY;
+		goto fail;
+	}
+	addr = pci_resource_start(pdev, 1);
+	outb(COR_VALUE, addr);
+	mdelay(1);
+	reg = inb(addr);
+	if (reg != COR_VALUE) {
+		printk(KERN_ERR "orinoco_tmd: Error setting TMD COR values %x should be %x\n", reg, COR_VALUE);
+		err = -EIO;
+		goto fail;
+	}
+
+	dev = alloc_orinocodev(0, NULL);
+	if (! dev) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	priv = dev->priv;
+	dev->base_addr = pccard_ioaddr;
+	SET_MODULE_OWNER(dev);
+
+	printk(KERN_DEBUG
+	       "Detected Orinoco/Prism2 TMD device at %s irq:%d, io addr:0x%lx\n",
+	       pdev->slot_name, pdev->irq, pccard_ioaddr);
+
+	hermes_struct_init(&(priv->hw), dev->base_addr,
+			HERMES_IO, HERMES_16BIT_REGSPACING);
+	pci_set_drvdata(pdev, dev);
+
+	err = request_irq(pdev->irq, orinoco_interrupt, SA_SHIRQ, dev->name,
+			  dev);
+	if (err) {
+		printk(KERN_ERR "orinoco_tmd: Error allocating IRQ %d.\n",
+		       pdev->irq);
+		err = -EBUSY;
+		goto fail;
+	}
+	dev->irq = pdev->irq;
+
+	if(orinoco_action(priv, ORINOCO_REGISTER))
+		goto fail;
+	netdev_registered = 1;
+
+	/* register the memory access device */
+	orinoco_mem_dev_init(priv);
+	
+	return 0;		/* succeeded */
+
+ fail:	
+	printk(KERN_DEBUG "orinoco_tmd: init_one(), FAIL!\n");
+
+	if (priv) {
+		if (dev->irq)
+			free_irq(dev->irq, priv);
+		
+		kfree(priv);
+	}
+
+	if (pccard_ioaddr)
+		release_region(pccard_ioaddr, pccard_iolen);
+
+	pci_disable_device(pdev);
+
+	return err;
+}
+
+static void __devexit orinoco_tmd_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct orinoco_private *priv = dev->priv;
+
+	if (! dev)
+		BUG();
+
+	/* unregister memory access device */
+	orinoco_mem_dev_cleanup(priv);
+	
+	orinoco_action(priv, ORINOCO_UNREGISTER);
+		
+	if (dev->irq)
+		free_irq(dev->irq, priv);
+		
+	pci_set_drvdata(pdev, NULL);
+
+	kfree(dev);
+
+	release_region(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));
+
+	pci_disable_device(pdev);
+}
+
+
+static struct pci_device_id orinoco_tmd_pci_id_table[] __devinitdata = {
+	{0x15e8, 0x0131, PCI_ANY_ID, PCI_ANY_ID,},      /* NDC and OEMs, e.g. pheecom */
+	{0,},
+};
+
+MODULE_DEVICE_TABLE(pci, orinoco_tmd_pci_id_table);
+
+static struct pci_driver orinoco_tmd_driver = {
+	.name		= "orinoco_tmd",
+	.id_table	= orinoco_tmd_pci_id_table,
+	.probe		= orinoco_tmd_init_one,
+	.remove		= __devexit_p(orinoco_tmd_remove_one),
+	.suspend	= 0,
+	.resume		= 0,
+};
+
+static char version[] __initdata = "orinoco_tmd.c 0.01 (Joerg Dorchain <joerg@dorchain.net>)";
+MODULE_AUTHOR("Joerg Dorchain <joerg@dorchain.net>");
+MODULE_DESCRIPTION("Driver for wireless LAN cards using the TMD7160 PCI bridge");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("Dual MPL/GPL");
+#endif
+
+static int __init orinoco_tmd_init(void)
+{
+	printk(KERN_DEBUG "%s\n", version);
+	return pci_module_init(&orinoco_tmd_driver);
+}
+
+extern void __exit orinoco_tmd_exit(void)
+{
+	pci_unregister_driver(&orinoco_tmd_driver);
+	current->state = TASK_UNINTERRUPTIBLE;
+	schedule_timeout(HZ);
+}
+
+module_init(orinoco_tmd_init);
+module_exit(orinoco_tmd_exit);
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ * End:
+ */
diff -Nru pcmcia-cs-3.2.8.orig/wireless/userhermes.c pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/userhermes.c
--- pcmcia-cs-3.2.8.orig/wireless/userhermes.c	1970-01-01 01:00:00.000000000 +0100
+++ pcmcia-cs-3.2.8-hermesap-and-fixes/wireless/userhermes.c	2006-03-18 16:27:20.000000000 +0100
@@ -0,0 +1,477 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/io.h>
+#include <errno.h>
+#include <readline/readline.h>
+#include <readline/history.h>
+#include <linux/types.h>
+
+typedef __u8 u8;
+typedef __u16 u16;
+typedef __u32 u32;
+
+#include "hermes.h"
+
+#define BAP_BUSY_TIMEOUT (50)
+#define CMD_BUSY_TIMEOUT (100) /* In iterations of ~1us */
+#define CMD_COMPL_TIMEOUT (20000) /* in iterations of ~10us */
+
+#define fatal(s) do { perror(s); exit(1); } while (0)
+
+typedef struct record_info {
+	u16 rid;
+	u16 len;
+	char *name;
+} record_info_t;
+
+record_info_t rid_table[] = {
+	{0xfc00,  2, "CNFPORTTYPE"},
+	{0xfc01,  6, "CNFOWNMACADDR"},
+	{0xfc02, 34, "CNFDESIREDSSID"},
+	{0xfc03,  2, "CNFOWNCHANNEL"},
+	{0xfc04, 34, "CNFOWNSSID"},
+	{0xfc05,  2, "CNFOWNATIMWIN"},
+	{0xfc06,  0, "CNFSYSSCALE"},
+	{0xfc07,  0, "CNFMAXDATALEN"},
+	{0xfc08,  0, "CNFWDSADDR"},
+	{0xfc09,  0, "CNFPMENABLED"},
+	{0xfc0a,  0, "CNFPMEPS"},
+	{0xfc0b,  0, "CNFMULTICASTRX"},
+	{0xfc0c,  0, "CNFMAXSLEEPDUR"},
+	{0xfc0d,  0, "CNFCNFPMHOLDDUR"},
+	{0xfc0e,  0, "CNFOWNNAME"},
+	{0xfc10,  0, "CNFOWNDTIMPER"},
+	{0xfc11,  0, "CNFWDSADDR1"},
+	{0xfc12,  0, "CNFWDSADDR2"},
+	{0xfc13,  0, "CNFWDSADDR3"},
+	{0xfc14,  0, "CNFWDSADDR4"},
+	{0xfc15,  0, "CNFWDSADDR5"},
+	{0xfc16,  0, "CNFWDSADDR6"},
+	{0xfc17,  0, "CNFMCASTPMBUFF"},
+	{0xfcb0,  0, "CNFSHORTPREAMBLE"}
+};
+
+#define NUM_RIDS (sizeof(rid_table) / sizeof(record_info_t))
+
+typedef struct record {
+	u16 len;
+	u16 type;
+	u16 value[4096];
+} record_t;
+
+
+/* Set up a BAP to read a particular chunk of data from card's internal buffer.
+ *
+ * Returns: < 0 on internal failure (errno), 0 on success, >0 on error from firmware 
+ *
+ * Callable from any context */
+static int hermes_bap_seek(ulong hw, int bap, u16 id, u16 offset)
+{
+	int sreg = bap ? HERMES_SELECT1 : HERMES_SELECT0;
+	int oreg = bap ? HERMES_OFFSET1 : HERMES_OFFSET0;
+	int k;
+	u16 reg;
+
+	/* Paranoia.. */
+	if ( (offset > HERMES_BAP_OFFSET_MAX) || (offset % 2) )
+		return -EINVAL;
+
+	/* Now we actually set up the transfer */
+	hermes_write_reg(hw, sreg, id);
+	hermes_write_reg(hw, oreg, offset);
+	/* Wait for the BAP to be ready */
+	k = BAP_BUSY_TIMEOUT;
+	reg = hermes_read_reg(hw, oreg);
+	while ( (reg & HERMES_OFFSET_BUSY) && k) {
+		k--;
+		reg = hermes_read_reg(hw, oreg);
+	}
+
+	if (reg & HERMES_OFFSET_BUSY)
+		return -ETIMEDOUT;
+	if (reg & HERMES_OFFSET_ERR)
+		return reg;
+
+	return 0;
+}
+
+/* Read a block of data from the chip's buffer, via the
+ * BAP. Synchronization/serialization is the caller's problem.  len
+ * must be even.
+ *
+ * Returns: < 0 on internal failure (errno), 0 on success, > 0 on error from firmware
+ *
+ * Callable from any context */
+int hermes_bap_pread(ulong hw, int bap, char *buf, u16 len,
+		      u16 id, u16 offset)
+{
+	int dreg = bap ? HERMES_DATA1 : HERMES_DATA0;
+	int err;
+
+	err = hermes_bap_seek(hw, bap, id, offset);
+	if (err)
+		return err;
+
+	/* Actually do the transfer */
+	hermes_read_data(hw, dreg, buf, len/2);
+
+	return 0;
+}
+
+/* Write a block of data to the chip's buffer, via the
+ * BAP. Synchronization/serialization is the caller's problem. len
+ * must be even.
+ *
+ * Returns: < 0 on internal failure (errno), 0 on success, > 0 on error from firmware
+ *
+ * Callable from any context */
+int hermes_bap_pwrite(ulong hw, int bap, const char *buf, u16 len,
+		       u16 id, u16 offset)
+{
+	int dreg = bap ? HERMES_DATA1 : HERMES_DATA0;
+	int err;
+
+	if (len % 2)
+		return -EINVAL;
+
+	err = hermes_bap_seek(hw, bap, id, offset);
+	if (err)
+		return err;
+
+	/* Actually do the transfer */
+	hermes_write_data(hw, dreg, buf, len/2);
+
+	return 0;
+}
+
+void usage(void)
+{
+	fprintf(stderr, "Usage: userprism <base io> [showrecords]\n");
+	exit(1);
+}
+
+char *
+rl_gets (void)
+{
+	char * line;
+
+	/* Get a line from the user. */
+	line = readline ("> ");
+	
+	/* If the line has any text in it, save it on the history. */
+	if (line && *line)
+		add_history (line);
+	
+	return (line);
+}
+
+void display(unsigned long base)
+{
+#define DREG(name) printf("%-16s: %04x\n", #name, inw(base + HERMES_##name))
+	DREG(CMD);
+	DREG(PARAM0);
+	DREG(PARAM1);
+	DREG(PARAM2);
+	DREG(STATUS);
+	DREG(RESP0);
+	DREG(RESP1);
+	DREG(RESP2);
+	DREG(INFOFID);
+	DREG(RXFID);
+	DREG(ALLOCFID);
+	DREG(TXCOMPLFID);
+	DREG(SELECT0);
+	DREG(OFFSET0);
+	DREG(SELECT1);
+	DREG(OFFSET1);
+
+	DREG(EVSTAT);
+	DREG(INTEN);
+	DREG(EVACK);
+	DREG(CONTROL);
+	DREG(SWSUPPORT0);
+	DREG(SWSUPPORT1);
+	DREG(SWSUPPORT2);
+	DREG(AUXPAGE);
+	DREG(AUXOFFSET);
+	DREG(AUXDATA);
+#undef DREG
+}
+
+#undef udelay
+void udelay(ulong usec) {
+	struct timespec ts;
+
+	ts.tv_sec = 0;
+	ts.tv_nsec = 1000 * usec;
+	nanosleep(&ts, NULL);
+}
+
+static int hermes_issue_cmd(ulong base, u16 cmd, u16 param0)
+{
+	int k = CMD_BUSY_TIMEOUT;
+	u16 reg;
+
+	/* First wait for the command register to unbusy */
+	reg = hermes_read_regn(base, CMD);
+	while ( (reg & HERMES_CMD_BUSY) && k ) {
+		k--;
+		udelay(1);
+		reg = hermes_read_regn(base, CMD);
+	}
+	if (reg & HERMES_CMD_BUSY) {
+		return -EBUSY;
+	}
+
+	hermes_write_regn(base, PARAM2, 0);
+	hermes_write_regn(base, PARAM1, 0);
+	hermes_write_regn(base, PARAM0, param0);
+	hermes_write_regn(base, CMD, cmd);
+	
+	return 0;
+}
+
+int hermes_docmd_wait(ulong base, u16 cmd, u16 parm0)
+{
+	int err;
+	int k;
+	u16 reg;
+	u16 status;
+
+	err = hermes_issue_cmd(base, cmd, parm0);
+	if (err) {
+		return -EIO;
+	}
+
+	reg = hermes_read_regn(base, EVSTAT);
+	k = CMD_COMPL_TIMEOUT;
+	while ( (! (reg & HERMES_EV_CMD)) && k) {
+		k--;
+		udelay(10);
+		reg = hermes_read_regn(base, EVSTAT);
+	}
+
+	if (! (reg & HERMES_EV_CMD)) {
+		return -ETIMEDOUT;
+	}
+
+	status = hermes_read_regn(base, STATUS);
+
+	hermes_write_regn(base, EVACK, HERMES_EV_CMD);
+
+	if (status & HERMES_STATUS_RESULT)
+		return -EIO;
+
+	return 0;
+}
+
+int read_lt(ulong base, int bap, u16 rid, record_t *rec)
+{
+	int err;
+
+	err = hermes_docmd_wait(base, HERMES_CMD_ACCESS, rid);
+	if (err) {
+		fprintf(stderr, "Cannot access RID 0x%04x\n", rid);
+		return err;
+	}
+
+	err = hermes_bap_pread(base, bap, (char *)rec, 4, rid, 0);
+	if (err) {
+		fprintf(stderr, "Error %d reading type/length\n", err);
+		return err;
+	}
+
+	if (rid != rec->type) {
+		fprintf(stderr, "RID (0x%04x) doesn't match rec->type (0x%04x)\n",
+			rid, rec->type);
+		return -1;
+	}
+
+	if (rec->len <= 1) {
+		fprintf(stderr, "Record too short, rec->len = %d\n", rec->len);
+		return err;
+	}
+
+	/* Convert length to bytes */
+	rec->len = 2 * (rec->len - 1);
+
+	err = hermes_bap_pread(base, bap, (char *)&rec->value, rec->len, rid, 4);
+	if (err) {
+		fprintf(stderr, "Error %d reading value (%d bytes)\n", err, rec->len);
+		return err;
+	}
+
+	return 0;
+}
+
+void
+show_records(unsigned long base)
+{
+	int i, j;
+	record_t rec;
+
+	printf("%d records total.\n", NUM_RIDS);
+	for (i = 0; i < NUM_RIDS; i++) {
+		record_info_t *info = &rid_table[i];
+		printf("Record %s [0x%04x]:", info->name, info->rid);
+		if (info->len)
+			printf(" expected length %04d\n", info->len);
+		else
+			printf("\n");
+
+		if (read_lt(base, 1, info->rid, &rec) != 0)
+			continue;
+		printf("Type 0x%04x, Len %04d: ", rec.type, rec.len);
+		for (j = 0; j < rec.len / 2; j++)
+			printf("%04x:", rec.value[j]);
+		printf("\n");
+	}
+}
+
+void
+show_record(unsigned long base, u16 rid)
+{
+	record_t rec;
+	int j;
+
+	if (read_lt(base, 1, rid, &rec) != 0)
+		return;
+	printf("RID 0x%04x: ", rid);
+	printf("type=0x%04x len=%04d value=", rec.type, rec.len);
+	for (j = 0; j < rec.len / 2; j++)
+		printf("%04x:", rec.value[j]);
+	printf("\n");
+}
+
+void do_line(unsigned long base, const char *line)
+{
+	char reg[100];
+	int off;
+	int val;
+	int n;
+
+	n = sscanf(line, "%s %i\n", reg, &val);
+	if (n < 1 || n > 2) {
+		fprintf(stderr, "?\n");
+		return;
+	}
+
+	if (strcasecmp(reg, "CMD") == 0) {
+		off = HERMES_CMD;
+	} else if (strcasecmp(reg, "PARAM0") == 0) {
+		off = HERMES_PARAM0;
+	} else if (strcasecmp(reg, "PARAM1") == 0) {
+		off = HERMES_PARAM1;
+	} else if (strcasecmp(reg, "PARAM2") == 0) {
+		off = HERMES_PARAM2;
+	} else if (strcasecmp(reg, "STATUS") == 0) {
+		off = HERMES_STATUS;
+	} else if (strcasecmp(reg, "RESP0") == 0) {
+		off = HERMES_RESP0;
+	} else if (strcasecmp(reg, "RESP1") == 0) {
+		off = HERMES_RESP1;
+	} else if (strcasecmp(reg, "RESP2") == 0) {
+		off = HERMES_RESP2;
+	} else if (strcasecmp(reg, "INFOFID") == 0) {
+		off = HERMES_INFOFID;
+	} else if (strcasecmp(reg, "RXFID") == 0) {
+		off = HERMES_RXFID;
+	} else if (strcasecmp(reg, "ALLOCFID") == 0) {
+		off = HERMES_ALLOCFID;
+	} else if (strcasecmp(reg, "TXCOMPLFID") == 0) {
+		off = HERMES_TXCOMPLFID;
+	} else if (strcasecmp(reg, "SELECT0") == 0) {
+		off = HERMES_SELECT0;
+	} else if (strcasecmp(reg, "OFFSET0") == 0) {
+		off = HERMES_OFFSET0;
+	} else if (strcasecmp(reg, "DATA0") == 0) {
+		off = HERMES_DATA0;
+	} else if (strcasecmp(reg, "SELECT1") == 0) {
+		off = HERMES_SELECT1;
+	} else if (strcasecmp(reg, "OFFSET1") == 0) {
+		off = HERMES_OFFSET1;
+	} else if (strcasecmp(reg, "DATA1") == 0) {
+		off = HERMES_DATA1;
+	} else if (strcasecmp(reg, "EVSTAT") == 0) {
+		off = HERMES_EVSTAT;
+	} else if (strcasecmp(reg, "INTEN") == 0) {
+		off = HERMES_INTEN;
+	} else if (strcasecmp(reg, "EVACK") == 0) {
+		off = HERMES_EVACK;
+	} else if (strcasecmp(reg, "CONTROL") == 0) {
+		off = HERMES_CONTROL;
+	} else if (strcasecmp(reg, "SWSUPPORT0") == 0) {
+		off = HERMES_SWSUPPORT0;
+	} else if (strcasecmp(reg, "SWSUPPORT1") == 0) {
+		off = HERMES_SWSUPPORT1;
+	} else if (strcasecmp(reg, "SWSUPPORT2") == 0) {
+		off = HERMES_SWSUPPORT2;
+	} else if (strcasecmp(reg, "AUXPAGE") == 0) {
+		off = HERMES_AUXPAGE;
+	} else if (strcasecmp(reg, "AUXOFFSET") == 0) {
+		off = HERMES_AUXOFFSET;
+	} else if (strcasecmp(reg, "AUXDATA") == 0) {
+		off = HERMES_AUXDATA;
+	} else if (strcasecmp(reg, ".") == 0) {
+		display(base);
+		return;
+	} else if (strcasecmp(reg, ",") == 0) {
+		if (n != 2) {
+			fprintf(stderr, "? No FID given\n");
+			return;
+		}
+		show_record(base, val);
+		return;
+	} else {
+		fprintf(stderr, "? Unknown register \"%s\"\n", reg);
+		return;
+	}
+
+	if (n == 2) {
+		printf("0x%04x -> 0x%04x\n", val, (int)base+off);
+		outw(val, base+off);
+	}
+	printf("%s (0x%04x) = 0x%04x\n", reg, off, inw(base+off));
+}
+
+int
+main(int argc, char *argv[])
+{
+	char *e;
+	unsigned long base;
+	int err;
+	char * line;
+	
+	if (argc < 2)
+		usage();
+
+	base = strtol(argv[1], &e, 0);
+	if (*e)
+		usage();
+
+	err = ioperm(base, 0x40, 1);
+	if (err != 0)
+		fatal("ioperm");
+
+	if (argc > 2) {
+		show_records(base);
+		exit(0);
+	}
+		
+
+	while (1) {
+		line = rl_gets();
+		
+		if (! line)
+			break;
+
+		do_line(base, line);
+
+		free(line);
+	};
+	
+
+	exit(0);
+}
